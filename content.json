{"meta":{"title":"Yisin's Blog","subtitle":null,"description":"可爱的Yisin呀","author":"Yisin","url":""},"pages":[{"title":"Yisin二三事","date":"2018-12-04T01:11:25.000Z","updated":"2019-12-15T08:23:42.584Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"生于浙江，长于浙江，冀北求学ing 真名XYX，但是大家一般叫我Yisin 是个蠢但是自带可爱属性的小仙女。 来自NEUQ的小菜鸡。梦想是成为wls那样的人。 平生所好，唯诗书与代码而已矣。 最喜欢的作家是书海沧生。 她的《昭奚旧草》、《十年一品温如言》、《同学录》都看了好多好多遍。 她能写尽世间一切求而不得。得之我幸，失之我命。 现在有一个非常非常喜欢的男朋友~他很厉害，但是是我的！ 兔兔，要是世上只有我们两个人多么好，我一定要把你欺负得哭不出来。 安安静静地读书，心无旁骛地敲代码。 如果你也有梦想，不妨一起来白日做梦吧！ QQ：997214586 E-mail：997214586@qq.com codeforces：Yisin0729 table{text-align: center;}时间事件2016-2017台州中学就读，技术考得贼辣鸡，VB算法自学成才2018.8来到NEUQ，参加暑期编程夏令营，自学C语言，一个星期以后转C++2018.9打星参赛CCPC秦皇岛站（人生第一场大型比赛）2018.9正式进入 NEUQ-ACM Club2018.11正式进入 NEUQ-ACM Club预备队2018.12.4第六届“图灵杯”NEUQ-ACM程序设计竞赛（个人赛）三等奖2018.12熬夜搭建个人博客，基本完工2019.1参加CCPC-Wannafly Winter Camp，认识wls等一众大神2019.4参加2050团聚，又认识了好多大佬小哥哥（小姐姐）2019.4“图灵杯”NEUQ-ACM程序设计竞赛（团体赛）第三名2019.5河北省赛铩羽，苟了银末2019.5西安邀请赛打铁，发誓下次回来一雪前耻2019.5科技节“最佳女生奖”，圆了去年校赛的遗憾2019.6南京女生赛铜奖，抱憾归来2019.7.7和我家兔兔在一起啦，超级超级稀饭他~2019.10.20厦门铁首，忽然感觉信念一瞬崩塌2019.10.26这天cf掉了140分2019.11.3ICPC徐州，我们队第一场区域赛铜2019.11.24ICPC上海，我们队最后一场铜2019.11.25学长退役，离开1117，我的青春结束了2019.12人生低谷，无需赘言 最好的年华，和最美好的自己相遇 这里是一只喜欢敲代码、喜欢写诗词、喜欢破产三姐妹的CuteYisin小仙女"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-11T09:49:37.179Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-11T10:15:17.459Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-11T10:30:27.306Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"code jam to i/O for Women 2019题解","slug":"code-jam-to-i-O-for-Women-2019题解","date":"2020-01-31T03:59:17.000Z","updated":"2020-02-12T03:12:29.310Z","comments":true,"path":"2020/01/31/code-jam-to-i-O-for-Women-2019题解/","link":"","permalink":"/2020/01/31/code-jam-to-i-O-for-Women-2019题解/","excerpt":"谷歌承诺 “building for everyone”。 Code Jam to I/O for Women 是谷歌提供的一个平台和机会，让全球顶尖的程序媛们华山论剑！ Code Jam to I/O for Women 是一个单轮的在线算法挑战！全球排名前 150 名的参与者，就有机会获得一张年度 Google I/O 大会的门票（包差旅）哦！！","text":"谷歌承诺 “building for everyone”。 Code Jam to I/O for Women 是谷歌提供的一个平台和机会，让全球顶尖的程序媛们华山论剑！ Code Jam to I/O for Women 是一个单轮的在线算法挑战！全球排名前 150 名的参与者，就有机会获得一张年度 Google I/O 大会的门票（包差旅）哦！！ code jam to i/O for Women 2019题解Grid EscapeProblemYou are designing a new “escape” adventure that uses a rectangular grid of rooms (unit cells) with R rows and C columns. Each room has four doors oriented in the four orthogonal directions of the grid: north, south, east, and west. The doors on the border of the grid lead outside, and all of the other doors lead to other rooms. The adventure will be played by exactly R × C players, with each player starting in a different one of the R × C rooms. Once everyone is in position and the game starts, all of the doors close, and there is a mechanical trick: one of the four doors in each room can be opened from inside the room, and the other three doors cannot be opened. This remains consistent throughout the adventure; in a given room, it is always the same door that can be opened. Notice that it is possible that a door that connects two rooms might be able to be opened from one side but not the other. Each player moves independently of all other players. Players can only go through doors that they opened themselves, and they must close doors behind them. Each player will keep going through doors until they go through a door that leads outside (and therefore they escape), or they have made R × C moves without escaping (at which point they are considered to have failed, and they do not escape). You want to choose which door in each room can be opened, such that exactly K of the players will be able to escape. Can you find a way to do this, or determine that it is IMPOSSIBLE? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line containing three integers R, C, and K, as described above. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is IMPOSSIBLE if there is no solution, or POSSIBLE if there is. If there is a solution, output R more lines of C characters each, representing the grid of rooms. The j-th character on the i-th of these lines represents the room in the i-th row and j-th column of the grid; each character must be either uppercase N, S, E, or W, according to whether the door that opens from that room is the one that leads north, south, east, or west. If multiple answers are possible, you may output any one of them. Limits1 ≤ T ≤ 100. Time limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. 1 ≤ R. 1 ≤ C. 0 ≤ K ≤ R × C. Test set 1 (Visible) 1 ≤ (R × C) ≤ 8. Test set 2 (Hidden) 1 ≤ (R × C) ≤ 100. SampleInput 2 2 3 2 1 1 0 Output Case #1: POSSIBLE SES SNW Case #2: IMPOSSIBLE In our solution for Sample Case #1, the two players who start in the westernmost two rooms will go south until they escape, whereas the four players who start in the other four rooms will travel between those rooms in an endless clockwise circle and cannot escape. In Sample Case #2, there is only one room, so the player can definitely escape regardless of which particular door can be opened. 解题思路这是一道构造题。每个人构造方式必然不尽相同，分享一下我的思路吧。 首先我们需要明确什么时候直接输出IMPOSSIBLE。一开始我以为只有1 1 0才满足这个条件。但是后来在写构造的过程中我发现只要满足条件C*W-k==1的，都是不能够构造出来的。 采用反证法，假设C*W-k==1可以构造，即所有格子只有一个格子不能逃脱。那这个格子不管开哪扇门，必然都可以进入可逃脱区，与已知不能逃脱相悖。因此C*W-k==1是不能被构造的。 那么我们可以从后往前对格子进行可逃脱赋值。最后一排格子标记为’E’,剩余只需要标记为’S’，即可从右下角离开。完成这部分标记后，需对剩余格子进行一遍搜索配对。 如果我们选取两个相邻格子，让他们可以开启同一扇门（即相邻边），则这两个格子都无法逃脱，陷入死循环。因此剩余偶数个格子时随意搜索应该都可以配对成功。 如果剩余奇数格子时，则只需要将最后三个格子配对，也可以形成死循环。 代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} char a[105][105]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { int r,c,k; cin&gt;&gt;r&gt;&gt;c&gt;&gt;k; if(r*c-k==1) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: IMPOSSIBLE&quot;&lt;&lt;endl; else { int x=r*c; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: POSSIBLE&quot;&lt;&lt;endl; for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { a[j][m]=&#39; &#39;; } } for(int j=0;j&lt;k;j++) { if((x-1)/c==r-1) { a[r][x%c==0?c:x%c]=&#39;E&#39;; } else { a[(x-1)/c+1][x%c==0?c:x%c]=&#39;S&#39;; } x--; } for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { if(a[j][m]==&#39; &#39;) { if(a[j+1][m]==&#39; &#39;) { a[j][m]=&#39;S&#39;; a[j+1][m]=&#39;N&#39;; } else if(a[j][m+1]==&#39; &#39;) { a[j][m]=&#39;E&#39;; a[j][m+1]=&#39;W&#39;; } else { if(j&gt;1) a[j][m]=&#39;N&#39;; else if(m&gt;1) a[j][m]=&#39;W&#39;; } } } } for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { cout&lt;&lt;a[j][m]; } cout&lt;&lt;endl; } } } return 0; } Parcel PostsProblemYou just bought a parcel of land that is K kilometers long; it is so narrow that, for the purposes of this problem, we will consider it to be a polyline that runs from west to east, varying in elevation. You know the elevations of the land (in meters) at K + 1 regularly spaced measurement marks M0, M1, …, MK. These marks are 0, 1, …, K km, respectively, from the western end. In this region, a wooden post denotes the boundary between two adjacent parcels of land. Wooden posts can only be placed at measurement marks, and there can be at most one post at each mark. Right now, there are two posts: one at the 0 km mark, and one at the K km mark. A measurement mark with a post is considered to be part of both of the parcels it demarcates, so your parcel of land includes all measurement marks between 0 and K km, inclusive. A parcel is considered desirable if it contains three measurement marks such that the west-most and east-most of those three marks are both strictly higher than the remaining one of the three marks, or both strictly lower than the remaining one of the three marks. People like some variation in their landscapes! Notice that these three marks are not necessarily consecutive, and the west-most and east-most of the three marks are not necessarily the west-most and east-most marks of the parcel. Consider an example with K = 5 and M0, M1, …, MK = 5, 6, 6, 1, 2, 4. The measurement marks with elevations 5, 2, and 4 satisfy the condition, as do the measurement marks with elevations 6, 1, and 2. However, the measurement marks with elevations 6, 6, and 1 do not satisfy the condition, nor do the measurement marks with elevations 1, 2, and 4. Any three measurement marks that satisfy the condition make the whole parcel desirable; for example, a parcel containing the measurement marks 4 7 6 7 is desirable because of the first three values. Your parcel is desirable, but you think it may be possible to extract even more value from it! You want to add additional posts to this parcel to divide it up into multiple parcels, all of which must be desirable, since you do not want to waste any land. What is the largest number of posts you can add? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each case begins with one line containing an integer K: the length, in kilometers, of your parcel of land. Then, there is one more line with K + 1 integers M0, M1, …, Mk; where Mi is the elevation (in meters) at the measurement mark that is i km from the western end of your land. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the largest possible number of posts you can add, as described above. LimitsTime limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. 1 ≤ T ≤ 100. 0 ≤ Mi ≤ 1000, for all i. (Mi - Mj) × (Mk - Mj) &gt; 0, for some i &lt; j &lt; k. (Your starting parcel is desirable.) Test set 1 (Visible) 4 ≤ K ≤ 10. Test set 2 (Hidden) 4 ≤ K ≤ 1000. SampleInput 4 4 4 8 7 3 5 4 4 8 7 7 5 7 1 2 2 1 2 1 2 1 6 2 1 3 10 9 12 20 Output Case #1: 1 Case #2: 0 Case #3: 2 Case #4: 1 In Sample Case #1, you can add one post at 2 km to get a total of two desirable parcels. The parcel from 0 to 2 km is desirable because 4 &lt; 8 and 8 &gt; 7. The parcel from 2 to 4 km is desirable because 7 &gt; 3 and 3 &lt; 5. In Sample Case #2, there is no way to add another post. If you added one at 1 km or 3 km, one of the parcels would include only two measurement marks and could not be desirable. If you added one at 2 km, the parcel between 0 and 2 km would be desirable, but the parcel between 2 and 4 km would not. In Sample Case #3, posts can be added at 3 km and 5 km. In Sample Case #4, a post can be added at 2 km. Notice that the parcel from 2 km to 6 km is desirable because 10 &gt; 9 and 9 &lt; 12. However, there is no way to add a second post. 解题思路我真的没想到……就是个暴力（努力想了半天发现数据小，而且！给了20s！！！绝了。这大概也是跟codeforces最大的不同吧，无法想象codeforces给20s是一种怎样的体验。） 首先我们要明确题意（这题目真的非常绕），实质是问你最多能将数组w划定多少个区间，使得每个区间内存在i&lt;j&lt;k，且w[i]&lt;w[j],w[k]&lt;w[j],或者w[i]&gt;w[j],w[k]&gt;w[j]。 那么我们可以通过枚举区间的右端点，极端暴力是O(n^3)，二分优化可以做到O(n^2logn)。但是题目时限非常宽，所以就直接暴力了。 #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int m[1005]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int t; cin&gt;&gt;t; for(int temp=1;temp&lt;=t;temp++) { int k; cin&gt;&gt;k; for(int i=0;i&lt;=k;i++) cin&gt;&gt;m[i]; int ans=0,i,j; for(i=0;i&lt;=k;i=j) { for(j=i+2;j&lt;=k;j++) { int flag=0; for(int x=i+1;x&lt;j;x++) { if((m[x]&gt;m[i]&amp;&amp;m[x]&gt;m[j])||(m[x]&lt;m[i]&amp;&amp;m[x]&lt;m[j])) { ans++; flag=1; break; } } if(flag) break; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;temp&lt;&lt;&quot;: &quot;&lt;&lt;ans-1&lt;&lt;endl; } return 0; } SheepwalkingProblemBleatrix Trotter is a sheep who lives in a two-dimensional field that is an infinite grid of unit cells. Her home is in a unit cell that we denote as (0, 0) — that is, all coordinates are given relative to Bleatrix’s home cell. However, because she has been sleepwalking, she is currently in the unit cell at the coordinates (X, Y) — that is, in a cell X columns east of, and Y rows north of, her home cell. The two sheepdogs who have been assigned to protect Bleatrix have just noticed that she is missing, and now they want to herd her back to her home cell. Before each of Bleatrix’s moves, the two sheepdogs can move to any grid cells that they want, except that they cannot both move to the same cell, and neither one can move to Bleatrix’s current cell. Once the sheepdogs are in place, Bleatrix, who is sleepwalking, will make a random unit move in a direction that would not take her into a cell with a sheepdog. That is, she takes the set of four possible unit moves (north, south, west, east), discards any that would move her into a cell with a sheepdog, and then chooses uniformly at random from the remaining moves. Then the sheepdogs can position themselves again, and so on (notice that, unlike Bleatrix, the sheepdogs do not have to make unit moves). Once Bleatrix arrives at her home at (0, 0), she stops sleepwalking, wakes up, and grazes peacefully, and does not make any more moves thereafter. If the sheepdogs coordinate their movements to minimize the expected number of Bleatrix’s moves to reach her home, what is that expected number? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each case consists of one line with two integers X and Y, representing the coordinates of Bleatrix’s starting cell, as described above. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the expected number of Bleatrix’s moves, as described above. y will be considered correct if it is within an absolute or relative error of 10-6 of the correct answer. See the Competing section of the FAQ for an explanation of what that means, and what formats of real numbers we accept. LimitsTime limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. (X, Y) ≠ (0, 0). Test set 1 (Visible) 1 ≤ T ≤ 48. -3 ≤ X ≤ 3. -3 ≤ Y ≤ 3. Test set 2 (Hidden) 1 ≤ T ≤ 100. -500 ≤ X ≤ 500. -500 ≤ Y ≤ 500. SampleInput 1 -1 1 Output Case #1: 4.000000 Notice that the values of X and/or Y may be negative. An X value of -1, for example, means that the cell is one unit west of Bleatrix’s home cell. (Similarly, a negative value of Y means the cell is south of Bleatrix’s home cell.) In the sample case, Bleatrix starts off one cell to the north of, and one cell to the west of, her home. Before she makes her first move, the two sheepdogs could position themselves in cells (-2, 1) and (-1, 2). Then, whichever direction she might choose, she would end up only one step away from her home… but the sheepdogs could not guarantee that she would go there on her next move! The remaining details are left for you to discover.","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"博弈论初探","slug":"博弈论初探","date":"2020-01-27T06:17:36.000Z","updated":"2020-02-12T04:10:51.985Z","comments":true,"path":"2020/01/27/博弈论初探/","link":"","permalink":"/2020/01/27/博弈论初探/","excerpt":"我们把动物利用大自然移动的瘾魂， 在决策人期待的空间里， 形成三维均衡的学术理论， 称为博弈论。 社会学领域非常经典的博弈论问题就是囚徒困境， 在算法竞赛领域的博弈论往往归纳为ICG（公平组合游戏），典型表现为取石子游戏。","text":"我们把动物利用大自然移动的瘾魂， 在决策人期待的空间里， 形成三维均衡的学术理论， 称为博弈论。 社会学领域非常经典的博弈论问题就是囚徒困境， 在算法竞赛领域的博弈论往往归纳为ICG（公平组合游戏），典型表现为取石子游戏。 博弈论初探博弈论入门之巴什博弈 有n个物品放置一堆，两个人轮流从中取物， 规定每次至少取1个，最多取m个，最后取光者得胜。 我们从最简单的情景开始分析 当石子有1~m个时，毫无疑问，先手必胜 当石子有m+1个时，先手无论拿几个，后手都可以拿干净，先手必败 当石子有m+2~2m时，先手可以拿走几个，剩下m+1个，先手必胜 我们不难发现，面临m+1个石子的人一定失败。 这样的话两个人的最优策略一定是通过拿走石子，使得对方拿石子时还有m+1个 设当前的石子数为n=k∗(m+1)+r 先手会首先拿走r个，接下来假设后手拿走x个，先手会拿走m+1−x个，这样博弈下去后手最终一定失败 设当前的石子数为n=k∗(m+1) 假设先手拿x个，后手一定会拿m+1−x个，这样下去先手一定失败 例题 hdu1846 巴什博弈裸题 #include&lt;cstdio&gt; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n%(m+1) !=0) printf(&quot;first\\n&quot;); else printf(&quot;second\\n&quot;); } return 0; } hdu4764 唐和江是好朋友。为了决定晚餐谁请客，他们在玩游戏。具体来说，唐和江将轮流在白板上写数字(整数)。唐先写，然后写江，再写唐，等等……此外，假设前一轮中所写的数字是X，下一个玩游戏的人应该写一个数字Y，使1 &lt;= Y - X &lt;= k。第一个写数字不小于N的人将输掉游戏。注意，在第一轮中，Tang只能在[1,k]范围内(包括1和k)写下一个数字。你可以认为唐和江的表现将一直处于最佳状态，因为他们都是非常聪明的学生。 我们可以把模型抽象一下,有n−1个石子，一个人最多拿k个，问最后谁赢 ——》裸的巴什博奕 #include&lt;cstdio&gt; int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m)) { if((n-1)%(m+1) !=0) printf(&quot;Tang\\n&quot;); else printf(&quot;Jiang\\n&quot;); } return 0; } hdu1847 巴什博弈的一个小变形。第一个必胜态不难推理出来是3。那么再仔细想，其实只需要用到1和2，等同于k值为2的巴什博弈。 #include&lt;cstdio&gt; int main() { int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { if(n%3!=0) printf(&quot;Kiki\\n&quot;); else printf(&quot;Cici\\n&quot;); } return 0; } 博弈论入门之斐波那契博弈 有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍 斐波那契博弈有一个非常重要的性质： 先手必败，当且仅当石子数为斐波那契数 是不是很神奇？？ 证明如下： n=2 先手输 n=3 先手输 假设n&lt;=k，且牌数为Fibonacci数时，都是先手必输。 那么n=k+1时，因为F(k+1)=F(k)+F(k−1)，即要取完F(k+1)张牌，可以分成两步：先取完F(k−1)张牌，再取完F(k)张牌。对于F(k−1)张牌，先取A者输！意味着对于F(k)张牌，A还得必须先取，所以A输。 那么，牌数为非Fibonacci数时，先取牌者有没有必胜的策略呢？ 引用一个定理：当一个数不是Fibonacci数时，这个数必然等于若干个Fibonacci数之和，并且这些Fibonacci数在Fibonacci数列中都不相邻。 对于非Fibonacci数a，a=f(n)+…+f(i)+f(j) ，其中f(j)是式中最小的Fibonacci数，f(i)是第二小的Fibonacci数。 由于f(i)、f(j)在Fibonacci数列中并不是相邻的，所以f(i)&gt;2∗f(j)。所以先取者可以直接取走f(j)张牌，后取者无法一次取走f(i)张牌，f(i)是Fibonacci数，由前面的分析，后取者必败。 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; map&lt;int,int&gt;mp; void init() { ll a=1,b=2; mp[a]=1,mp[b]=1; for(int i=3;i&lt;100;i++) { ll c=a+b; a=b; b=c; mp[a]=1,mp[b]=1; } } int main() { int n; init(); while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) { if(mp[n]) printf(&quot;Second win\\n&quot;); else printf(&quot;First win\\n&quot;); } return 0; } 博弈论入门之nim游戏 有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利？ 面对新的博弈问题，我们按照套路，从简单的情况入手 当只有1堆石子的时候，先手可以全部拿走。先手必胜 当有2堆石子且石子个数相同的时候，先手不论拿多少，后手都可以从另一堆中拿同样多的石子，先手必败，否则先手必胜 当有三堆的时候呢？ 当有n堆的时候呢？ 这样玩下去确实是很繁琐，不过前辈们总结出了一条非常厉害的规律！ 当n堆石子的数量异或和等于0时，先手必胜，否则先手必败 证明如下： 设^表示异或运算 nim游戏的必败态我们是知道的，就是当前n堆石子的数量都为零 设a[i]表示第i堆石子的数量，那么当前局面就是 0 ^ 0 ^ 0 ^ … ^ 0 = 0 对于先手来说，如果当前局面是 a1 ^ a2 ^ a3 ^ … ^ an = k 那么一定存在某个ai，它的二进制表示在最高位k上一定是1 我们将ai ^ k，这样就变成了 a1 ^ a2 ^ a3 ^ … ^ an ^ k = 0 此时先手必胜 对于先手来说，如果当前局面是 a1 ^ a2 ^ a3 ^ … ^ an = 0 那么我们不可能将某一个ai异或一个数字后使得 a1 ^ a2 ^ a3 ^ … ^ an = 0 此时先手必败 例题 洛谷P2197 Nim裸题 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { int t;scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m=0;scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { int x;scanf(&quot;%d&quot;,&amp;x); m^=x; } if(m) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0; } POJ1704 好巧妙的Nim啊！！！ 首先我们想到一种必败态：即仅有两个点且相邻 那么我们可以把所有的点排序之后两两捆绑，这样如果A移动第一个，那么B可以把第二个移动相同的步数 这样我们就解决了顺序的问题 那么接下来就考虑如何解决博弈问题 这里有个神仙操作 把两点直接的距离看做一堆石子，然后请Nim来就可以啦 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int a[1005]; int main() { int t;scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m;scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a,a+n); if(n&amp;1) { m=a[0]-1; for(int i=2;i&lt;n;i+=2) m^=(a[i]-a[i-1]-1); } else { m=0; for(int i=1;i&lt;n;i+=2) m^=(a[i]-a[i-1]-1); } if(m) printf(&quot;Georgia will win\\n&quot;); else printf(&quot;Bob will win\\n&quot;); } return 0; } 变形 Moore’s Nim n堆石子，每次从不超过k堆中取任意多个石子，最后不能取的人失败。 这是一个nim游戏的变形，结论：把n堆石子的石子数用二进制表示，统计每个二进制位上1的个数，若每一位上1的个数mod(k+1)全部为0，则必败，否则必胜。 证明： 全为0的局面一定是必败态。 任何一个P状态，经过一次操作以后必然会到达N状态：在某一次移动中，至少有一堆被改变，也就是说至少有一个二进制位被改变。由于最多只能改变k堆石子，所以对于任何一个二进制位，1的个数至多改变k。而由于原先的总数为k+1的整数倍，所以改变之后必然不可能是k+1的整数倍。故在P状态下一次操作的结果必然是N状态。 任何N状态，总有一种操作使其变化成P状态。从高位到低位考虑所有的二进制位。假设用了某种方法，改变了m堆，使i为之前的所有位都回归到k+1的整数倍。现在要证明总有一种方法让第i位也恢复到k+1的整数倍。 有一个比较显然的性质，对于那些已经改变的m堆，当前位可以自由选择1或0. 设除去已经更改的m堆，剩下堆i位上1的总和为sum 分类讨论： sum&lt;=k-m,此时可以将这些堆上的1全部拿掉，然后让那m堆得i位全部置成0. sum&gt;k-m 此时我们在之前改变的m堆中选择k+1-sum堆，将他们的第i位设置成1。剩下的设置成0.由于k+1-sum&lt;k+1-(k-m)&lt;m+1,也就是说k+1-sum&lt;=m，故这是可以达到的； anti-nim反nim游戏 正常的nim游戏是取走最后一颗的人获胜，而反nim游戏是取走最后一颗的人输。 一个状态为必胜态，当且仅当： 所有堆的石子个数为1，且NIM_sum(xor和)=0 至少有一堆的石子个数大于1，且 NIM_sum(xor和)≠0 新Nim游戏 在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。 如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。 为使后手必败，先手留给后手的必然是若干线性无关的数字，否则后手可以留下一个异或和为零的非空子集使得先手必败，故问题转化为拿走和最小的数字使得留下的数线性无关，即留下和最大的线性基，这样拿走的数量显然最少，找到和最大的线性基只需贪心的把数字从大到小加入到基中即可（证明需用到拟阵） bzoj3105 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int num[1005],d[1005]; bool cmp(int a,int b) { return a&gt;b; } int Insert(int k) { for(int i=31;i&gt;=0;i--) { if(k&amp;(1&lt;&lt;i)) { if(!d[i]) { d[i]=k; return 1; } else k^=d[i]; } } return 0; } int main() { int k;ll m=0; scanf(&quot;%d&quot;,&amp;k); for(int i=0; i&lt;k; i++) scanf(&quot;%d&quot;,&amp;num[i]); sort(num,num+k,cmp); for(int i=0; i&lt;k; i++) { if(!Insert(num[i])) m+=num[i]; } printf(&quot;%lld&quot;,m); return 0; } Nim游戏求方案总数 给定一个Nim状态，求该状态能够到达获胜状态的方案总数。 若该状态为P状态，则Nim和为零，肯定方案总数为0 若Nim和不为零，则表明该状态处于N状态，由于该位置是N位置，所以Nim和不为零，我们要求有多少总方案，改变其状态，使Nim和为零。 Nim和的求法为x1,x2,x3…xn的异或和，考察第一堆石头，设a=x1,b=(x2+x3+…+xn)，那么: Nim=a^b—————————1 假设改变a即第一堆石头的数目之后，新的Nim和为0,即: Nim’=a’ ^ b=0———————2 由于改变了石头的数目，必有: a’&lt;a———————————3 由方程1,2可以得到b=Nim ^ a = Nim’ ^ a’,又Nim’=0，故: Nim ^ a= a’————————4 将得到的方程4带入方程3，得到关系式： Nim ^ a &lt; a————————5 也就是说，对于每一堆石头来说，只要满足关系式5，则就一定可以通过将这一堆的石头的数目改变从而使新的Nim和为0，也就是从N位置转移到P位置。统计共有多少堆石头满足关系式5，就有多少种转移的方案啦。 poj2975 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int num[1005]; int main() { int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) { ll m=0;int ans=0; for(int i=0; i&lt;n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); m^=num[i]; } for(int i=0; i&lt;n; i++) { if((num[i]^m)&lt;num[i]) ans++; } printf(&quot;%d\\n&quot;,ans); } return 0; } 2020 CCPC-Wannafly Winter Camp Day2 C 如何将上一题O(n^2)降为O(nlogn)？当然是位运算啦！ 因为 y &gt; x ^ y，所以y的最高位一定高于或等于x的最高位，否则x的最高位不变，不满足 考虑异或和的最高的为 1 的二进制位，所有这一位是 1 的 y 显然都满足条件，这一位是 0 的都不满足条件。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int cnt[65]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); ll a,b=0; for(int i=0; i&lt;n; i++) { scanf(&quot;%lld&quot;,&amp;a); b^=a; ll x=a; int k=0; for(int j=0;x;j++) { cnt[j]+=x%2; x/=2; } ll sum=b; while(sum) { sum/=2; k++; } printf(&quot;%d\\n&quot;,cnt[k-1]); } return 0; } 博弈论入门之威佐夫博弈 有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利 定义先手必输的局势为奇异局势，前几个奇异局势为 (0,0),(1,2),(3,5),(4,7),(6,10)… 假设(x,y)为第k个奇异局势 性质： x为前1…k个奇异局势中没有出现过的最小正整数，y=x+k 任何一个自热数都包含在一个且仅有一个奇异局势中 证明有需要可以自寻，窝已经绕晕了QWQ 人们通过对上述性质的探索，同时结合Betty定理，给出了威佐夫博弈的重要结论 假设两堆石子为(x,y)（其中x&lt;y） 那么先手必败，当且仅当 (y−x)∗(√5+1)/2=x 其中的(√5+1)/2实际就是1.618…，黄金分割数！ POJ1067 #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #define ll long long using namespace std; int main() { int a,b; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF) { if(a&gt;b) swap(a,b); int c=(b-a)*(sqrt(5.0)+1.0)/2.0; if(c==a) puts(&quot;0&quot;); else puts(&quot;1&quot;); } return 0; } 51NOD 1185 威佐夫游戏 V2 这题本来也是裸题，但是！ 可恶的出题人卡精度红红火火恍恍惚惚 然后我尝试了一下python3交 python真香~ from decimal import * from math import sqrt t=int(input().strip()) for case in range(t): a, b = map(int, input().strip().split()) p=Decimal((Decimal(5).sqrt()+1)/2) dif=abs(a-b) a=min(a,b) if a==int(p*dif): print(&quot;B&quot;) else: print(&quot;A&quot;)","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"/tags/博弈论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"我的2019","slug":"我的2019","date":"2020-01-18T08:05:20.000Z","updated":"2020-01-18T08:32:22.391Z","comments":true,"path":"2020/01/18/我的2019/","link":"","permalink":"/2020/01/18/我的2019/","excerpt":"虎头蛇尾。 开启无限可能。 这是我的2019。","text":"虎头蛇尾。 开启无限可能。 这是我的2019。 我的2019不知道2019对大家意味着什么？ 如果让我来说的话，这是崭新的一年。开启了和吴东同学的爱情之旅，这也是这一年最大的记忆点。 也许我之前梦想中的那个人，","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"新年","slug":"新年","permalink":"/tags/新年/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"dp专题","slug":"dp专题","date":"2019-12-16T11:51:38.000Z","updated":"2019-12-16T13:22:47.522Z","comments":true,"path":"2019/12/16/dp专题/","link":"","permalink":"/2019/12/16/dp专题/","excerpt":"这是我非常抗拒的一个算法点QAQ 因为真的很难 一直下意识地逃避不想学。 But最好面对恐惧的办法就是！疯狂刷题！！！ Yisin冲呀~ 感谢awen给我们开的套题。特此鸣谢~","text":"这是我非常抗拒的一个算法点QAQ 因为真的很难 一直下意识地逃避不想学。 But最好面对恐惧的办法就是！疯狂刷题！！！ Yisin冲呀~ 感谢awen给我们开的套题。特此鸣谢~ dp专题A - Sum of Different Primes题目传送门 以我拙劣的英语水平翻译一下是这样的：给你多组n和k，问用k个不同质数加和为n有多少种方案。 嘿咻！忽略掉质数和不重复两个关键词的话，这道题和《算法竞赛入门到进阶》（今年的一本新书，推荐，作者是华理的竞赛教练）dp入门的一题十分相似。 原题（hdu2069）如下：题目传送门 有n种硬币，面值分别为v1,v2,…,vn，数量无限。输入非负整数s，选用不多于100个硬币，使其和为s。输出所有可能的硬币组合。 那么我们可以定义一个矩阵元素dp[i][j]，含义是用j个硬币实现金额i的数量方案。 第一步：只用1分硬币实现初始dp[0][0]=1，其他为0。定义int type[5]={1,5,10,25,50}为5种硬币的面值。那么可以推导出来 dp[1][1] = dp[1][1] + dp[0][0] = dp[1][1] + dp[1-1][1-1] = 0 + 1 = 1dp[1-1][1-1]是因为从1分金额里减去1分硬币的钱，1个硬币的数量也减少了1个。 所以这一步实际上是dp[1][1] = dp[1][1] + dp[1-type[0]][1-1] 第二步：加上5分硬币，继续进行组合dp[i][j]，当i&lt;5时，组合里不可能有5分硬币。当i&gt;=5时，金额为i，硬币为j个的组合数量等价于从i中减去五分钱，而且硬币数量也减去1个的情况。dp[i][j] = dp[i][j] + dp[i-5][j-1] = dp[i][j] + dp[i-type[1]][j-1] 第三步：陆续加上10分、25分、50分硬币，同理有以下关系：dp[i][j] = dp[i][j] + dp[i-type[k]][j-1]，k=2,3,4 所以代码就是 //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[5]={1,5,10,25,30}; int dp[251][101]; int n,k; void solve() { dp[0][0]=1; for(int i=0;i&lt;5;i++) { for(int j=1;j&lt;101;j++) { for(int k=type[i],k&lt;251;k++) { dp[k][j]+=dp[k-type[i]][j-1]; } } } } int main() { int s;int ans[251]={0}; solve(); for(int i=0;i&lt;251;i++) { for(int j=0;j&lt;101;j++) ans[i]+=dp[i][j]; } while(cin&gt;&gt;s) cout&lt;&lt;ans[s]&lt;&lt;endl; return 0; } 明白了这道硬币题，那么这道题的思路也是一样的。只不过给定的数需要自己求。数据最大是1120，所以打个素数筛轻而易举，将1120前所有质数放进type数组里面。 所以一开始我是这么写的 //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[1005],ans=0; ll dp[2005][20]; int n,k; void init() { for(int i=2;i&lt;=1120;i++) { int flag=1; for(int j=2;j*j&lt;=i;j++) { if(i%j==0) { flag=0; break; } } if(flag) type[ans++]=i; } } void solve() { dp[0][0]=1; for(int i=0;i&lt;ans;i++) { for(int j=1;j&lt;=k;j++) { for(int m=type[i];m&lt;=n;m++) { dp[m][j]+=dp[m-type[i]][j-1]; } } } } int main() { init(); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)==2&amp;&amp;(n||k)) { mem(dp,0); solve(); cout&lt;&lt;dp[n][k]&lt;&lt;endl; } return 0; } 然后我发现事情并不简单，因为这个程序连样例也并不能完全通过。于是我开始了漫长的debug之路，最后找到了问题所在！这个程序是有可能取重复素数的，因为取硬币的时候并没有要求每种类型只能取一个，但是这题规定了一个素数只能被加一次。 辣么，解决方案是什么呢？ 让我们倒着来想。 dp[m][j]+=dp[m-type[i]][j-1]意味着： 当 type[i] 在 dp[m-type[i]][j-1] 的计算中已经有可能被使用的情况下仍然继续被使用。 那么，如果我们换成dp[m+type[i]][j]+=dp[m][j-1]，并让之前的加法倒转成一个减法呢？ 也就是如下的循环： for(int i=0;i&lt;ans;i++) { for(int j=k;j&gt;0;j--) { for(int m=n-type[i];m&gt;=0;m--) { dp[m+type[i]][j]+=dp[m][j-1]; } } } 一开始我也不太明白这个循环是怎么回事，后来观察了一下每一步的相加元素，就清楚了。一开始只有到dp[0][0]才能有值，所以只有dp[type[0]][1]才会有值。根据dp[type[0]][1]，所以dp[type[0]+type[1]][2]也会有值；再根据dp[0][0],dp[type[1]][1]也会有值……就完成了每个元素的全排列。已经被用过的值是不可能再被使用的。妙啊！ 所以这道题的最终程序是： //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[1005],ans=0; ll dp[2005][20]; int n,k; void init() { for(int i=2;i&lt;=1120;i++) { int flag=1; for(int j=2;j*j&lt;=i;j++) { if(i%j==0) { flag=0; break; } } if(flag) type[ans++]=i; } } void solve() { dp[0][0]=1; for(int i=0;i&lt;ans;i++) { for(int j=k;j&gt;0;j--) { for(int m=n-type[i];m&gt;=0;m--) { dp[m+type[i]][j]+=dp[m][j-1]; } } } } int main() { init(); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)==2&amp;&amp;(n||k)) { mem(dp,0); solve(); cout&lt;&lt;dp[n][k]&lt;&lt;endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"dp","slug":"dp","permalink":"/tags/dp/"},{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"梦碎石家庄","slug":"梦碎石家庄","date":"2019-11-18T11:35:26.000Z","updated":"2019-12-15T08:11:55.011Z","comments":true,"path":"2019/11/18/梦碎石家庄/","link":"","permalink":"/2019/11/18/梦碎石家庄/","excerpt":"渭城朝雨浥轻尘 客舍青青柳色新 劝君更尽一杯酒 西出阳关无故人 低吟白雪逢阳春 送君别去无知音 高台孤矗昂首望 穹凄尽兮宙宇敞 车马纵兮雁飞翔 春复秋往世无常 幽清默兮落暗乡 何年何月蹉跎降 莫问莫观你莫惆怅 山石林木无易样","text":"渭城朝雨浥轻尘 客舍青青柳色新 劝君更尽一杯酒 西出阳关无故人 低吟白雪逢阳春 送君别去无知音 高台孤矗昂首望 穹凄尽兮宙宇敞 车马纵兮雁飞翔 春复秋往世无常 幽清默兮落暗乡 何年何月蹉跎降 莫问莫观你莫惆怅 山石林木无易样两年前，诗词大赛上，我们从耻辱之队到所向披靡再到痛失冠军。但是那是我高三最幸福的时刻，我可以逃避那些堆积成山的试卷，可以逃避那昏昏欲睡的课堂，读着自己喜欢的诗，干着自己喜欢的事情。 被钉在耻辱柱上的那天，赛前，老师们信心满满，你们就随便玩玩，第一出线应该不难。然后，我们是出线了，但是是以最后一名的身份。那天我哭得很惨，在自己最喜欢的事情上输了，还是这样的惨烈。 应该答对的，我紧张，犹豫，答错了；加上诗词面实在窄，虽然在校内以第二的名次进入的校队，但是我读的诗大部分是喜爱其风格词句，集中度比较高。那天比赛前，我还非常高兴地喊了两个好朋友来看我比赛。等她们到的时候，比赛已经结束了，她们只看到哭成泪人的我在凳子上心如刀绞。 初战不利。于是指导老师想出了封闭式训练的办法。一个月为期，我们的目标是冠军。那个时候刚考完第一次选考，其实我有自己的私心，我不想囿于昏昏欲睡的课堂了，我想干点自己喜欢的。所以，即使我的父母，我的班主任他们所有人都在反对，我跟他们耗了很久，终于得到了折中的办法，重要的课例如数学课我必须去上，其他的随我自己。 那是多么快乐的日子啊！自由潇洒似神仙。而一起相处的人，都是一样热爱诗词的人，虽无流觞曲水之盛况，亦存以诗相和，以词相逗。老师也对我非常好，读诗词之余，他也单独给我讲一些提升语文成绩的办法，并且承诺我高三的语文他包了。 第二次出征的时候我们碰到的都是弱队，不费吹灰之力甩了第二名一百分的分差。那时的激动，现在想来也会微微一笑吧。 半决赛，我们碰到了强劲的对手——温岭中学。正如高考成绩上的针锋相对，赛场上我们都对对方虎视眈眈。双方最后平局，于是需要加赛一轮。我们中唯一的男生自告奋勇（但是后来因为这个又成为一件伤心的往事），一分之差险胜。但是赛后温岭中学质疑我们作弊，闹得沸沸扬扬。事情很快被平息，比赛的主持人（也是我非常喜欢的小哥哥）徐志那时候对他们说，没关系，以后你们终会站上更大的舞台。 是啊，多年以后，这时的一时得失又算得了什么。 决赛，其实我们的表现无功无过。妙手丹青、飞花令一样优势，但是答题上面不占优势，诗词常识的功底太浅了。三轮玩下来我们和回浦中学玩成了平局，所以需要加赛。其实后面的发挥就与我无关了。最后没有迎来奇迹，差一点也是差一点。 那个时候最欢乐的时光，虽然结局并非完美，但是已经很开心了。 两年后，本以为和这些绝缘的我遇到了另一个机会——河北省人文知识竞赛。我的心里有一个梦，我告诉自己，圆梦的时候来了。 出线省赛比我想象中容易。本以为自己好些年没触碰这些，会显生疏。但是有些东西印在脑子里，是忘不掉的。我的强项，大抵也就是诗词了吧。 去石家庄的那周刚好碰到大物考试，所以也没办法准备。当时想的是，反正就去玩一玩，我对拿奖其实没什么渴求，也就是想和大家切磋一下而已。 一考完大物我和其他两个男生就踏上了火车，去追赶大部队的步伐。第二天的笔试其实我自己感觉还行。跌跌撞撞我们闯进了半决赛。 当时其实我也像两年前那样期许自己能顺利晋级决赛。多么美丽的梦呀~那天晚上大家都很努力地在准备第二天的表演。emmmm其实我也说不上想台前还是幕后，我的抗压性有点差，所以就怕上台犯怂，最后让学妹上了，我旁白。 半决赛的可惜大概比两年前更难受吧（www 我还清晰地记得前面都是古诗词，我答的很顺手，然后出现了一句诗“梅子留酸软齿牙，芭蕉分绿与窗纱”描写的是哪个季节，我第一反应是“夏季”，写完了以后顺口问了大家一句要不要写“初夏”，然后大家都说不用，我就没有改。最后答案公布就初夏，夏季不得分。我当时真的超级大的失落感，白白葬送了十分。 还有一题是说河北的民间音乐，我们中有一个河北学长，他当时非常没有把握地说了一个“京韵大鼓”，然后本来想写了，另外一个妹子说了个“莲花落”，当时我们觉得她说的好像很有道理，然后就采用了她的答案。最后答案还是“京韵大鼓”。 表演环节我的电脑开始罢工，然后就白白耽误了五分钟左右。我当时真的很慌，感觉印象分绝对被拉低了。 其他组的题目都很正常，是历史事件之类的。只有我们是“丁是丁卯是卯”，像极了相声主题。我们很无奈，只能把这句话寓于我们的故事中，最后定下的《挥泪斩马谡》。 我们就止步于这里了。一如两年前。Yisin的梦大概是碎了，醒了，心里的花也死了。不知道明年有没有机会，但是再也不能这么肆意地去追逐这样的东西了。 我本楚狂人，凤歌笑孔丘。 红颜弃轩冕，白首卧松云。 醉月频中圣，迷花不事君。 可是， 欲闻华亭鹤唳，可复得乎 曾经它的结尾是问号。现在大抵是个叹号了。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"},{"name":"心情","slug":"心情","permalink":"/tags/心情/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"十月末の小记","slug":"十月末の小记","date":"2019-10-29T12:46:06.000Z","updated":"2019-10-31T12:25:47.930Z","comments":true,"path":"2019/10/29/十月末の小记/","link":"","permalink":"/2019/10/29/十月末の小记/","excerpt":"十月十月十月， 好像又陷入了悲伤的漩涡。 觉得自己一事无成， 觉得自己资质平庸。","text":"十月十月十月， 好像又陷入了悲伤的漩涡。 觉得自己一事无成， 觉得自己资质平庸。 十月末の小记十月恍恍惚惚就过到了月末。 感觉这个月好像经历了很多事情，但是却一事无成？ 月初国庆选拔赛拿到了去往上海的资格，实现了今年赛区“三过家门而不入”。然后五号一次团建，虽然饭菜并没有非常如意，但是和兔子的第一次集体旅行还值得一提。 然后迷迷糊糊就去了厦门。这个学期的第一站。然后，赛后本来还很激动地以为自己首战就可以拿铜，结果，铁首。厦门的悲伤不太想赘述，因为回忆起来真的十分难受。不敢置信，我们队如今实力居然还有可能打铁。这意味着我一直对我们的巨大憧憬幻灭了。 中间经历了一场大学物理波动与光学考试。其实这门课我已经算学得很认真了。平心而论，我认为跟大一学线性代数的状态差不多，一开始听得比较认真，只是后面跟的比较吃力，久而久之就有些气馁了。 但是感觉和周围人的状态相比还是偏努力一点？也许是方法的问题，学习这种理论性学科我向来缺乏经验。但是也不甘心直接撇弃。 考完以后的感觉就是重点其实全部都扫到了，但是由于复习的战线拉得过长，前面一些东西的印象不深，考试的时候脑子一片空白。但是其实考完感觉还可以，毕竟大部分都是那种一眼题，出错的概率还是很小的。 等待成绩的日子既紧张又轻松，既烦躁又开心。但是最后看到成绩的那刻人都不好了。不算差，比之前进步很多，然而比预期低了一些。问了一下室友的成绩，结果发现她的成绩也比我高了一截……（泪崩 于是最后，得知全年级九十分以上占比百分之六十。相对无言，唯有泪千行。 这件事的悲伤持续了很久，以至于我开始对自己产生怀疑。那年高考我对于计算机的选择是不是就是个错误。虽然高中一开始确实文理比较平均，没有特别出色的，然后为了追求成绩的最大化，田忌赛马式地选了历史政治技术，虽然也是真心喜欢这些科目，毕竟还是存了那些心思的。 感性，文艺，这些词一直伴随着我。就算在文科班，我的语文水平也是顶尖的，甚至最后我都是朝年级前几的语文成绩发起进攻的。我喜欢语文，我喜欢历史，我本可以岁月静好地留在省内读文学，但是，“今日长缨在手，何时缚住苍龙”？就是因为对黑客的向往，我背井离乡了，断了自己对文科的路。 时至今日，我仍然记得历史老师对我寄予的殷切希望。那是我高三最后的光。他说，相信我可以冲一冲浙大；每次考完试我总会缠着他帮我分析试卷；甚至最后，我和他聊理想，谈历史。我当初，也是很真心地喜欢这个老师，并且想成为和他一样的光。但是，最后我背叛了自己跟他说的梦想。 假如当初再努力一些……其实高考不选择文科不单纯是因为对计算机爱的深沉。只是文科的分数普遍高，而去一个不怎么知名的学校我也不愿意。放弃文科，第一痛苦的是另一个梦想，第二痛苦的就是现在被数理折磨。 然后，这个月的月底，进了河北省人文知识竞赛。参加这个比赛纯粹当放松，加分奖项我从来不缺，就当是为了当初被放弃的另一个梦想奋斗几周。高三的诗词大会，真真是最美好的时光。 又扯了好多呀。唉，悲伤的十月…… 但是还是要继续加油鸭！","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"},{"name":"心情","slug":"心情","permalink":"/tags/心情/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"CCPC厦门站团队赛后总结","slug":"CCPC厦门站团队赛后总结","date":"2019-10-27T09:24:32.000Z","updated":"2019-10-27T09:29:19.848Z","comments":true,"path":"2019/10/27/CCPC厦门站团队赛后总结/","link":"","permalink":"/2019/10/27/CCPC厦门站团队赛后总结/","excerpt":"人生如逆旅 我亦是行人","text":"人生如逆旅 我亦是行人 2019.10.20-2019CCPC厦门赛区赛后总结solved：2/12Rank：140/238，Iron Medal赛中解决的问题 A: 1:25:54 J: 04:57:37(-2) 赛后总结20188117 项溢馨 终于能好好回首这场比赛，赛后在火车上的那段时间躲在自己的悲伤里，不想再去触碰厦门的回忆。厦门打铁，运气不好是很小的一部分因素。如果用题目太难，有效队伍变少做借口，那只能说明水平实力不够。但是我觉得不管什么情况下，我们打铁也是不应该的。我和学长先读的题，我觉得G是签到，他看了J觉得有点麻烦。所以我们就一起开了G。确定了大致思路以后，泽铭代码写了一半的时候，我们看了一眼榜，可以说是胆战心惊。大概有几十支队交题，只有两个队过题，交G的全WA了，过的全是其他题。但是当时我们还抱着一丝侥幸，也许我们就能成为天选之子。第一发提交理所当然地WA了。但是当时也没有几个队伍过题，所以我们决定继续找G的问题，开始了漫长的Debug之路。事实证明，当时这个决策非常的错误，不仅延长了过第一题的时间，还炸了队伍的心态。整G进入疲劳期的时候，我们看了一眼榜，发现G的过题率真的很低，反而是A更像签到题。A题主要是读题比较麻烦，但是思路很简单，所以读懂了以后基本没有什么障碍。A过的时候不算太慢，大概中上水平。但是问题就在于接下来开哪题。一番商量过后决定兵分两路，泽铭负责J，我和学长继续找G的错误。期间两个人时常切换谁用电脑，但是最后泽铭写完交的时候并没有过。这种情况需要三个人一起找错误。但是由于我自己对J理解不深，所以和学长都支持先看G。浪费了大量时间。最后一小时泽铭看实在不行了，强制性地让学长一起看J。事实证明，还好泽铭当时的判断比较准确，最后十分钟左右，通过一遍一遍的寻找，泽铭终于发现是复制粘贴的时候忘记改个小地方了，偏偏所有样例都对了。恰巧那时候我手表停了，所以我以为还有可能把G一起过了。但是过了J后不久，比赛就结束了。这次比赛我的确犯了一些比较严重的决策错误。之前我们有过读了很多题但是写不了，耗费了读题时间的问题，所以这次我过于保守，没有在卡题的时候另开一题，我的责任挺大。而且没有做到答应jyf学长的鼓励队友，自己变成了一个自闭怪。若非泽铭最后的正确抉择，我们可能输得更惨。我自己的个人实力也确实在退步，究其根本是觉得自己不用做主代码手，所以松懈得很厉害。我自己在态度上也应该反思。确实感觉和大一时候的那种热情不太一样了。现在变得功利，变得想抱大腿，变得慢慢不那么喜欢ACM了。但是就像父亲说过的，自己选的路，得走完。把兴趣变成一项事业，有利有弊。你也许会变得更加充满动力，也许会变得逐渐厌恶这种生活。但是不管怎么样，已经不仅仅是兴趣了，不可以半途而废。可能有些太急于求成了吧。一想到学长即将退役，一想到黄金时期即将消逝，一想到自己前途渺茫。我自己本身就是一个会想很多的人，包袱太多。顺境还好，一旦逆境，可能真的会抑郁到崩溃。总之这次比赛真的是一个很好的教训。让我更清楚地认识到自己的本质。希望下次比赛可以轻松一点，有准备一点。 20187874 刘泽铭 感觉比赛时最大的问题就是没有找到状态。A题过了之后因为当时榜全都带向了G，就一直在死抠G。虽然后来我去写了J，但也因为最开始想法有问题，wa了一次后也没有在上面花太多心思。最后半小时一行一行读代码，才发现一个函数名写错了，改完就过了，觉得代码熟练度的问题很大。 不会打逆风的场，在中期顺风转逆风后，没有考虑去重新看榜（现场OJ不能直接查看每道题过题人数，只能看排行榜自己估计），也不敢再去读题，导致出题人数远多于G的H和D都没有读，直到结束还一直以为G是过题第三多的题。 比赛经验不足，开局读完G，看到榜上红一片的时候就应该果断放弃G，而不是头铁自信敲。 20177866 卢佳星 这次厦门站依旧白给了，感觉全队的状态不是很好，做题策略上有很大的问题，在之前，我们一直是同时开两道题，而在做两道题的人之间却缺少交流，思路不是很开阔，而这次在三个人同时卡住的情况下，我们却没有及时得换题，导致所有人的思维僵住了，做题效率非常的低。 我在开场是就读到了G题，在没有想明白的情况下，想当然的认为是一道简单的进制转换题，并且在榜上已经阵亡十多个队的情况下，还是没有意识到自己的思路存在问题。在写完带了几组样例之后才发现自己思路上的问题和题目中是正好卡了ull的范围的需要转换成大数，或者写高精度，由于不熟悉大数，写了很多奇怪的bug出来，还彻底把自己写懵掉了，导致自己完全的陷在那道题里了，以至于最后一直在挂机。","categories":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}]},{"title":"Coloring a Tree","slug":"Coloring-a-Tree","date":"2019-09-26T11:25:52.000Z","updated":"2019-09-26T12:26:57.581Z","comments":true,"path":"2019/09/26/Coloring-a-Tree/","link":"","permalink":"/2019/09/26/Coloring-a-Tree/","excerpt":"题目链接&lt;–点这里 这段时间写了好多dfs，感觉这题比较有挑战？看了眼题解才想到思路，然后代码实现感觉也不太简单……","text":"题目链接&lt;–点这里 这段时间写了好多dfs，感觉这题比较有挑战？看了眼题解才想到思路，然后代码实现感觉也不太简单…… Coloring a Tree题目链接&lt;–点这里 题目意思： 给你n个点，代表这一棵树有n个节点。第二行内容是建树的关系，从第二个节点开始的节点和父节点（上一个节点）相连， 例如：1 2 2 1 5 代表：节点2和节点1相连，节点3和节点2相连，节点4和节点2相连，节点5和节点1相连，节点6和节点5相连。 第三行内容是需要将各个点涂成的颜色，给这个树涂色，有这么一条原则就是给某一节点涂色，以其为根节点的子树也将变为相应的颜色，问你最终需要最少需要涂多少次颜色就可以满足题目要求。 解题思路：我们可以这样来思考，因为最后需要使所有的点都涂成要求的颜色，一定是按照从根节点到叶子节点遍历的涂色，但所有的点都遍历会造成浪费，我们只需要找出需要涂的点即可。 那么哪些点需要涂呢？我们发现只有那些最后要求的其父亲节点和本身不同色的需要涂色，因为需要向下改变自身颜色，那么只需要统计这样点的个数即可。 一开始我苦思冥想怎么建树，把层次关系可以弄明白。但是后来发现完全不需要，只需要记录每个节点的父节点是谁就好了。我采用的是结构体排序，每对父子节点都存两遍，改变先后顺序。之后从根节点开始，把所有存在父子关系的点都加入节点i的队列。再从根节点的队列开始遍历，把每个没有更新父节点的节点当成当前节点的子节点。 sum的初值是1，因为根节点肯定需要涂色。然后从2到n扫一遍，当前节点与当前节点的父节点是否属于一种颜色，不相同则sum++。 #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} struct Tree { int l,r; }t[20005]; bool cmp(Tree a,Tree b) { if(a.l==b.l) return a.r&lt;b.r; return a.l&lt;b.l; } int father[10005]; int color[10005]; queue&lt;int&gt;q[100005]; int main() { ios::sync_with_stdio(false); int n,ans=0; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) { int y; cin&gt;&gt;y; t[ans].l=i;t[ans++].r=y; t[ans].l=y;t[ans++].r=i; } for(int i=1;i&lt;=n;i++) { cin&gt;&gt;color[i]; father[i]=-1; } //cout&lt;&lt;1&lt;&lt;endl; sort(t,t+ans,cmp); for(int i=0;i&lt;ans;i++) { q[t[i].l].push(t[i].r); } for(int i=1;i&lt;=n;i++) { while(!q[i].empty()) { if(father[q[i].front()]==-1&amp;&amp;q[i].front()!=1) { father[q[i].front()]=i; } q[i].pop(); } } int sum=1; for(int i=2;i&lt;=n;i++) { if(color[i]!=color[father[i]]) sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; }","categories":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"},{"name":"dsu","slug":"dsu","permalink":"/tags/dsu/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"}],"keywords":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}]},{"title":"走出舒适圈","slug":"走出舒适圈","date":"2019-08-21T02:55:27.000Z","updated":"2019-08-21T03:40:16.844Z","comments":true,"path":"2019/08/21/走出舒适圈/","link":"","permalink":"/2019/08/21/走出舒适圈/","excerpt":"我本身还是一个挺喜欢安逸的人，也从来厌恶自己不了解的领域，发自内心的害怕。 记得金学长曾经的签名是，走出舒适圈，远离垃圾人。或许挺对的吧。","text":"我本身还是一个挺喜欢安逸的人，也从来厌恶自己不了解的领域，发自内心的害怕。 记得金学长曾经的签名是，走出舒适圈，远离垃圾人。或许挺对的吧。看今年的小萌新们，难免有些感慨。 虽说严于律己，宽以待人，我可能还是那种除非彻底失望，否则还是更愿意把待人待己的标准放一致。我又不是什么神仙，我能做到的，大家也应该可以呀；我自己也做不到的，emmmm，那自然不能去强加在别人身上嘛。 出题这件事其实是很恼火的。两次一共贡献了八道题，每一次都找了好几个人验过题，力争难度中等。 也问过同高中的学弟，他觉得难度很ok，想一想在一个小时内还是可以写完的。何况我第二次还削了难度。 最后还是被吐槽出题太难。 是，要我出那种简单题确实做不到。我不觉得那些题目应该拿来给你们当作业，那个自己练习几遍就OK了，当作业的话就不存在动力了。dbq，我就是那种严以待人的人，和你们其他温柔的学长学姐不一样。我清楚地知道我现在的水平不是因为天赋多么多么高，而是学的时候把命拼上。 我也想过，自己去年为什么那么幸运呢？提前搭上ACM的车，暑假提前就刷了一个学期应该练习的题量。认识awen或许是一个偶然，但是进入ACM肯定是必然。可能参加训练营的大家也未必都想进入这个圈子，所以，我没有拿去年我写过的题的难度为难大家呀，只是一些大家不能直接想出来的程序，训练思维和代码能力。 只是我自己这段时间其实也挺颓的吧。不喜欢写自己不擅长的题，所以写来写去还在原地徘徊。知识盲区依旧很多。醒的也越来越晚。 而且，感觉，又有好朋友越走越远吧。虽然和兔兔在一起以后，确实也没有太多时间一起聊聊天了。而且现在明显感觉到了分歧，或许是我变了。算了，就当是我变了，也好过看着他变了。 希望都能走出舒适圈吧。 共勉。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"生活记录","slug":"生活记录","permalink":"/tags/生活记录/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"【2019】【NEUQ-ACM SUMMER CAMP】第九次课程作业解题报告","slug":"【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告","date":"2019-08-11T09:12:36.000Z","updated":"2019-08-11T10:43:05.373Z","comments":true,"path":"2019/08/11/【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告/","link":"","permalink":"/2019/08/11/【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告/","excerpt":"我出题比较喜欢安一个有趣冗长的背景，考查思维的题目。 所以可能很多小盆友都自闭了。 下面奉上题解，请食用。求轻喷。","text":"我出题比较喜欢安一个有趣冗长的背景，考查思维的题目。 所以可能很多小盆友都自闭了。 下面奉上题解，请食用。求轻喷。 【2019】【NEUQ-ACM SUMMER CAMP】第九次课程作业解题报告兔子与快乐水读题使人快乐。 题目大意可以理解为三堆可乐，两个人轮流挑一堆，最后一堆随意分配。求最后分到最少可乐的那个人最多能分得多少可乐。 乍一看是道博弈论的题目，实际是简单的脑筋急转弯。 我们可以这样思考，求最大值，那么浪费一定是最少的。那么，我们可以先取三堆可乐中较少的两堆，分别记为x1,x2，剩下来的最大堆的可乐数目（x3）一定不小于前两堆可乐的差值，即x3&gt;=abs(x1-x2)。 那么我们模拟这个过程。第三堆先用来补前两堆的差值，剩余部分平分，加起来就是正确答案。 然鹅~ 不需要这么麻烦。上文说过，求最大值，那么浪费一定是最少的。我们尽力做到不浪费的方法就是尽可能平分这三堆可乐。所以实际上最后就是一个求⌊总和/2⌋的过程。这种做法的正确性证明其实就是上一种做法。 记得定义变量需要long long 此题over XD 兔子的加班表一维数组应用。 很多同学疑惑怎样才能求出连续的1。 其实很简单。可以设置一个maxn表示1的最大连续数量，ans表示当前连续1的数量。通过循环判断当前若是1，则ans+1；当前若是0，则把之前ans与maxn比较，更新maxn大小，并把ans重新置0。 至于如何实现首尾相接呢？ 提供两种思路。 开两倍的数组。把两份相同加班表依次存入数组，这样子自然就是上一份的尾巴接在了下一份的头上。而且题目保证一定存在0，所以无需担心如果全是1则需减半的情况。 可以记录从数组第一个元素开始（如果有）和以最后一个元素为尾（如果有）的1的数量，最后加在一起。 兔子与玫瑰花园一维数组应用。 此题三种解法，层层优化。但是由于最后一种解法树状数组和线段树知识点过分难，在此不做赘述。只讲基础的两种。 一，最简单暴力写法。 初始化数组point[n]为0。可以在每输入一个区间[l,r]的同时，通过一重for循环把point[l]到point[r]置为1。最后只需要i从0到n循环判断point[i]大小，若为0则ans++，最后输出ans大小即可。 二，优化写法。（较难，看不懂的同学可以跳过） 读入m组区间两端点left[i]和right[left[i]]，第二个数组存在的意义是使直接通过左端点的值，就可以得知右端点的值。然后依据left[i]的值对数组进行排序。 对排序好的point数组遍历，扩展重叠区间的左右，即right[left[i]]&lt;=left[i+1]，则把区间右端点从right[left[i]]扩展为right[left[i+1]]。直至right[left[i]]&gt;left[i+1]，则把上个区间内point赋值为1。 接下去的做法同一。 这种做法节约了对重叠区间重复赋值的时间，但是比较难以理解。希望学有余力的同学可以好好思索，而且第二种做法数组也可用结构体代替。 祝大家下一次作业都AK！","categories":[{"name":"解题报告","slug":"解题报告","permalink":"/categories/解题报告/"}],"tags":[{"name":"解题报告","slug":"解题报告","permalink":"/tags/解题报告/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"/categories/解题报告/"}]},{"title":"字符串算法之Manacher","slug":"字符串算法之Manacher","date":"2019-08-07T02:06:01.000Z","updated":"2019-08-07T02:51:12.128Z","comments":true,"path":"2019/08/07/字符串算法之Manacher/","link":"","permalink":"/2019/08/07/字符串算法之Manacher/","excerpt":"Manacher算法， 又叫“马拉车”算法， 可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。","text":"Manacher算法， 又叫“马拉车”算法， 可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。 字符串算法之Manacher之前一直都在不知所云地套板子。 直到今天，下定决心，要搞懂Manacher的原理。 然后，原来不过如此嘛XD 从最简单的判断回文的方法说起。 即拉出字符串中的每个子串，判断它们是否回文。 拉出子串需要O(n^2),判断是否回文需要O(n)，所以这种方法的时间复杂度是O(n^3)。 那么再精巧一点，我们可以从字符串中的每个字符下手，对于每个字符向两边扩展求回文长度。这样子，时间复杂度降到了O(n^2)。 我们是否可以找到一种O(n)的算法呢？答案是肯定的。 不考虑dp的方法，其实我们能从回文串本身得到一些启示。 例如： c a b a d a b a b 我们运用第二种方法对每个字符进行分析。 从第二位a开始，b≠c，因此f[2]=1; 第三位b，c a b a d a b a b，因此，f[3]=3； 第四位a，b≠d，f[4]=1； 第五位d，c a b a d a b a b，因此，f[5]=7； 下面！！！高能！！！ 第六位a，b≠d，f[6]=1。但是！是不是觉得似曾相识？对！由于回文串具有对称性质，所以事实上，因为第四位构不成回文串，所以与此对应的第六位也是不可能有的。 第七位b，同理，第七位等同于第三位，f[7]=f[3]=3； 第八位a，是不是要脱口而出f[8]=f[2]=1？等等！我们发现 c a b a d a b a b ，因此，f[8]=3。这是为什么呢？由于s[1]≠s[9]，所以f[8]和f[2]是不一定相等的。 这样一个分析过程，实际上就是Manacher算法所需要做的。 首先，我们要记录下目前已知的回文串能够覆盖到的最右边的地方 同时，覆盖到最右边的回文串所对应的回文中心也要记录 以每一位为中心的回文串的长度也要记录，后面进行推断的时候能用到 对于新的中心，我们判断它是否在右边界内，若在，就计算它相对右边界回文中心的对称位置，从而得到一些信息，同时，如果该中心需要进行扩展，则继续扩展就行。 但是这样会出现一些问题，比如回文长度为偶数的时候，不存在严格意义上的回文中心。所以我们需要对字符串先进行一波预处理。 先对字符串进行预处理，两个字符之间加上特殊符号# 然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整） 每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度 判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界 最后得到最长回文之后，去掉其中的特殊符号即可 下面放上我觉得比较完美的一个板子 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; const int maxn = 2e5 + 10; char s[maxn], sNew[maxn&lt;&lt;1]; int p[maxn&lt;&lt;1], id, mx=0; int L, R; //回文串在原串的左右端点位置 int Init() { int len = strlen(s); sNew[0] = &#39;$&#39;; sNew[1] = &#39;#&#39;; int j = 2; for (int i = 0; i &lt; len; i++) { sNew[j++] = s[i]; sNew[j++] = &#39;#&#39;; } sNew[j] = &#39;\\0&#39;; return j; } int Manacher() { int len = Init(); int max_len = -1; mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); else p[i] = 1; while (sNew[i - p[i]] == sNew[i + p[i]]) p[i]++; if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } if(max_len &lt; p[i]) { max_len = p[i]; L = (i - p[i])&gt;&gt;1; R = (i + p[i] - 4)&gt;&gt;1; ///R = (i + p[i])/2 -2; } } return max_len; }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"/tags/字符串/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"2019·8·杂杂杂篇","slug":"2019·8·杂杂杂篇","date":"2019-08-05T01:53:16.000Z","updated":"2019-08-05T02:09:08.287Z","comments":true,"path":"2019/08/05/2019·8·杂杂杂篇/","link":"","permalink":"/2019/08/05/2019·8·杂杂杂篇/","excerpt":"七月悲喜交加 麦浪翻滚连同草地 直到天涯 八月就是八月 八月我守口如瓶 八月里我是瓶中的水 你是青天的云","text":"七月悲喜交加 麦浪翻滚连同草地 直到天涯 八月就是八月 八月我守口如瓶 八月里我是瓶中的水 你是青天的云 2019·8·杂杂杂篇此篇的由来是因为最近删了一些陈年博客，想补上心情记录。另外，某兔嘲笑我多长时间没更了，哼~ 很乏善可陈的八月，连七夕都要一个人过QAQ 但是我还是觉得我是世界上最幸福的小仙女，因为我有一只全世界最可爱的兔子~ 给自己列个计划清单好惹，看看月末能完成多少。 研究完字符串算法。包括但不限于Manacher、hash、字典树、KMP、AC自动机、后缀自动机。 学习密码学部分的基础概念和数学基础。 概率论入门。 每天背单词！做阅读理解！最好是能背一篇短文。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"生活记录","slug":"生活记录","permalink":"/tags/生活记录/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"字符串算法之hash","slug":"字符串算法之hash","date":"2019-08-05T01:36:58.000Z","updated":"2019-08-07T01:27:16.868Z","comments":true,"path":"2019/08/05/字符串算法之hash/","link":"","permalink":"/2019/08/05/字符串算法之hash/","excerpt":"Hash，一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。","text":"Hash，一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 字符串算法之hash我还是觉得hash好神奇。这到底是什么鬼东西啊喂！ 首先推荐三篇入门博客，我觉得写的十分精妙~ hash入门 hash进阶：使用字符串hash乱搞的姿势 字符串hash入门 这三篇博客已经基本把hash的前世今生交代清楚了。我再补充一点自己对hash的浅薄认识好了。一千个读者心中有一千个hash。众所周知，hash就是乱搞。hash是一种加密解密规则，类似于破译密码的一个过程。 我们对于子字符串每位进行一波操作，并不断累加。其关键步骤就是 h[i]=h[i-1]*base+s[i] 由此我们可以得到每个字符串对应的值。但是，hash冲突的产生就是这个值可能不是一一对应的，一个值也许对应了多个字符串。 尽量避免hash冲突的关键就在于对base这个进制以及模数的选择上，base一般选择大于字符串中的最大的字符且不含模数的值因子的数。 比如说，如果你是对一串小写字母做字符串hash，那么131这个进制就是不错的选择。 而模数的选取方式一般分为三种： 选择两个模数，判断的时候只有两个hash值都相同才算相同 选择一个大质数，像11111111111111111111111或者212370440130137957 用unsigned long long 自然溢出 那么区间hash值如何计算呢？ 因为hash实质上是将字符串进行进制转换的过程，所以对于区间内的hash值就是整体值去左去右分别对应的转换好的进制值。用公式表达就是这样子： ll get_hash(int l,int r){&emsp;&emsp;return h[r]-h[l-1]*p[r-l+1];} p[n]代表base的n次方。","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"/tags/字符串/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"戊戌变法剧本","slug":"戊戌变法剧本","date":"2019-05-29T16:58:03.000Z","updated":"2019-05-29T17:05:12.947Z","comments":true,"path":"2019/05/30/戊戌变法剧本/","link":"","permalink":"/2019/05/30/戊戌变法剧本/","excerpt":"高三时候看了一丢丢《北京法源寺》。 实在是令人拍案叫绝。 谨以此篇致敬李敖先生。","text":"高三时候看了一丢丢《北京法源寺》。 实在是令人拍案叫绝。 谨以此篇致敬李敖先生。 戊戌变法——改编自话剧《北京法源寺》，致敬李敖先生 人物： 戊戌六君子 谭嗣同，湖南人 （康广仁，广东人） 林旭，福建人 杨深秀，山西人 杨锐，四川人 （刘光第，四川人） 慈禧 光绪 袁世凯，河南人 康有为，广东人 梁启超，广东人 （建议按照地域选择人物，剧本偶有几句方言效果较好） （bgm1：《知否知否》起） 旁白：中国的近代史是一部屈辱史、抗争史、同时也是一部探索史。面对着帝国主义列强的大肆入侵和疯狂瓜分，中国人民在思索着寻找一条救亡图存之路，在帝国主义的隆隆炮声中，戊戌变法拉开了帷幕，国仇、家恨、抱负、野心也在这短短百日展现得淋漓尽致…… 第一幕 旁白：戊戌政变时，以慈禧太后为首的封建顽固派大肆捕杀维新党人，维新志士谭嗣同、康广仁、林旭、杨深秀、杨锐、刘光第六人于1898年9月28日在北京惨遭杀害，史称“戊戌六君子”。时人面对着变法失败的结局与危机，纷纷做出了自己的选择。 （bgm1终） 谭嗣同：我叫谭嗣同。戊戌年，我33岁。我想以我个人之躯，打破数亿国众的意识桎梏。而睁眼看看，保全自己是目前大多数人的选择，而我却选择一条极少有人走的道路——殉！ （PPT：殉 加个闪电音效） 杨锐：我是杨锐，戊戌变法重要人物之一。四川绵竹的（方言）。 杨深秀：我叫杨深秀，戊戌变法重要人物之一。我是山西的（方言）。 林旭：我是林旭，戊戌变法重要人物之一。我是福建人（方言）。 合：我们四个，砍头时间一致。1898年9月28日。 旁白：1890年，康有为梁启超认识时，梁启超才18岁，正当风华正茂的时候；而当时康有为已经33岁了。他们亦师亦友，一起领导了戊戌变法。我想知道他们为什么生，为什么死？ 康有为：我是康有为。我是广东人（粤语）。 梁启超：我叫梁启超。我选择生，看见现世，推动发展。 杨锐、杨深秀、林旭：我们选择病。国家病了，人也就病了。国病，人病，还有心病。 谭嗣同：我选择死。冥阳一隔，穿入自由！ 第二幕 （bgm2：《风起时》起） 旁白：康有为，一个以重建治道自命，苦心钻研政体，当属宰相之才，无奈沦落体制外的名士知识分子，从来自负宏大的目标与责任，认定弘道护国治国兴邦，兴利除弊圣徒使命非他一人。康有为，自幼通天理、好易学，苦读圣贤之书，以圣人转世自居。康有为，年轻游历香港内地，研读大乘佛教经典，弘扬普济救世之论。康有为，作为圣贤与救世的结合体，深情热爱着几千年的古国帝制，热情体恤着民族苍生。 （bgm2终） 康有为：我，曾以我卓越的学识和区区个人之体，救助过满目疮痍的大清。我曾七次上书朝廷，第一次六千字，第二次一万七千字，第三次一万五千九百四十一字。我见到了皇上，这一个时辰让中国历史有了意义。 （bgm3：《妖谭》起） 旁白：戊戌变法时，光绪帝推动了一系列的改革，涵盖政治、经济、军事、文教等领域，包括拟定宪法、开制度局、禁止妇女缠足、裁冗官、置散卿、废漕运、撤厘金、裁绿营、放旗兵、废八股试帖楷法取士、改书院、废淫祠等；要求保护工商业，要求重练海陆军……改革的事业蒸蒸日上，而这些都起源于一次简单的君臣相谈。 （bgm3终） 光绪：提倡民主思想。这是康有为对朕说的第一句话。平等看待世界，做观念的强人。这是他对朕说的第二句话。让顽固守旧的份子和封建官制，受到一次前所未有的威胁和挑战。但是，不是推翻。破固有之陋习，立济世之新学。变法维新，努力发奋，大振皇基。 康有为：皇上圣明！臣终于盼到了大清维新的曙光。呵护新政，我康有为在所不辞。 旁白：他们忘了戊戌变法一个重要人物，出卖变法重要人物，没有之一。 袁世凯：我，袁世凯。我是戊戌变法重要人物之一。（以下为方言）俺，袁世凯，俺与你康有为相识二十一年，共为好友三年。对西方宪政的认识，你我亦有相近之处。袁某钦佩你的胆力才华，谏言大清。我按月薪水二十两，一次性拿出了五百两，支持你维新变法。就是因为我认为，大清不改，不能有出路。再这样下去，大清就去球了！ 第三幕（bgm4《我是人家最招摇》起） 旁白：1898年（光绪二十四年）9月底光绪帝去天津阅兵时，慈禧太后等人早有密谋，发动兵变，废黜光绪帝，打算一举扑灭新政。为了挽救变法事业，谭嗣同密会新军统帅袁世凯。袁世凯假意向谭嗣同妥协，百般敷衍，并且打算在背后告密，难道谭嗣同看不出来吗？至此，谭嗣同也终于明白了自己真正的使命…… （bgm4终） 谭嗣同：维新阵营里人人都想有所作为。 袁世凯：可这些人物里，没有一位是实权派人物。手下连一支敢死队都没有。谭章京，您的成功率几乎是零。 谭嗣同：你作为新军统帅 袁世凯：我作为新军统帅 谭嗣同：戴着一副假面具 袁世凯：面具下谁能看出我的忠诚和隐忍 谭嗣同：外表开明实则保守，骑墙之徒。 袁世凯：是我，是历史，让谭章京这位四品大员，提早结束了政治生涯。 谭嗣同：你们杀掉的是我的肉身，我将灵魂驻世，后代传扬。 袁世凯：我的好名声，死在了戊戌年9月28日。 谭嗣同：我要面对的，是陈腐的政治制度；我要挑战的，是陈腐政治制度下，庞大的利益集团。 第四幕 （bgm5《周郎》起） 旁白：慈禧，这个中国历史上最后一个封建王朝清王朝末期的实际统治者，中国近代史上几乎每一件丧权辱国的事件都与之息息相关。戊戌政变是慈禧太后一生当中发动的第三次宫廷政变，第一次是1861年11月同恭亲王奕訢发动的辛酉政变，第二次是1884年4月懿旨罢斥恭亲王为首的全部军机处成员而以醇亲王代之的甲申易枢，三次政变都以慈禧太后的胜利而告终，也都成就了她垂帘听政的政治野心。 （bgm5终） 康有为：她是镇压戊戌变法重要人物，没有之一。她是个妖魔，诡诈阴险，权利心极重，杀人不眨眼。她杀了我亲弟弟，康广仁。 杨锐：菜市口六君子人头落地，国仇家恨于一身。我对她恨之入骨。 杨深秀：她是个泼妇。 林旭：她是个恶妇。 康有为：她是个阻挠变法，把中国推向黑暗的罪魁。 旁白：你想了解历史，不能以几种或者某种历史观来看待她。恶贯满盈的慈禧太后是否可能在为了一己私欲的政变中稍微考虑过国家利益呢？她是一个女人，一个非凡的女人。维新派对慈禧恶语相向，这是自然的，慈禧是维新的最大阻力。而慈禧太后对于变法自然也有自己的想法。 （Bgm6：《清平调》起） 慈禧：我身后，是一片惶惶然的大清版图。维新派，全变大变的急进变革主张，造成朝野内部结构和清朝社会结构的强烈震荡。百日维新期间，上谕达一百八十四件之多，几乎一天一个新策，全国百姓目不暇接。皇帝严惩阻挠变革的朝廷官员，操之过急，树敌深重。废除八股，改革科举制度，令庞大的士人群体引起普遍的恐慌。 有关国计民生，亦是无论新旧，皇帝都不得因噎废食。只除旧迎新，造成朝廷官员恐慌掣肘只谈守旧。大清又无力变法，需皇帝谨慎处之，平衡发展。变法岂是几日可得，需皇帝拼尽余生，忍耐智取。而宵小之徒，窃变法之说、煽乱之谋，我必不饶之。 皇上，你要爱国。你没有实权，怎么爱国？你这个聪明的孩子，就是没有考虑到这核心的危险。皇帝，你会成为大清最愚蠢的叛徒。 （Bgm6终） 第五幕 （Bgm7：《破阵曲》） 旁白：维新派担心掌握军权的荣禄先动手，计划武力夺权。他们准备利用正在天津训练新军的袁世凯，让他夺取荣禄兵权，然后带兵进京，包围颐和园，将西太后捕杀，这就是康有为的“围园杀后”之计。这就促使西太后从颐和园赶回紫禁城，抓捕康有为等维新派。袁世凯的告密，加剧和扩大了西太后的镇压行动。这样，维新变法不可避免地失败了。1898年9月19日，慈禧太后从颐和园返回西苑，瀛台问罪光绪皇帝。 （bgm7终） 慈禧：拟旨，宣布戊戌变法为戊戌政变。缉拿新党，新法尽废，恢复旧法。 杨锐：大人如见，重大事件。我即将被捕，罪名深重。恳请大人速想良策，拯救学生杨锐。 林旭：大人如见，本人与维新派一并垢罪，触及林旭性命。望大人速想良策。 杨深秀：大人如见，维新重创，即将累及深秀本人。深秀罪名不定，或可重判。 谭嗣同：大人如见，旧势力反扑，我命在旦夕。谭嗣同不求营救特此禀告大人。 梁启超：跟随康先生我参加了戊戌变法，成为了我想成为后世传颂的中国思想改良者。我没有做先驱，没有因为哪一场改革丧命，我是个幸运也不幸的人。幸运的是，我结识了谭嗣同和三个为变法而死的军机章京。我也经历过了灾难最深重的国运。作为一个幸存者，这个国家我必须去救。不幸的是，我失败了。虽然屡战，还是屡败。我想，谭嗣同。 谭嗣同：我以我血荐轩辕。谭嗣同支持皇上矢志变法，不以死者无以酬圣主，不以行者无以图将来。救亡图存！如果维新阵营里，我们这些人全都走了，变法就会成为一个笑话。这局棋里，有一步死棋，就是我。 当我必须面对死亡时，我必须找到一个必须去死的理由。作为变法人士，变法失败了，我有殉难的义务。可是我想对着这个国家呐喊，不变法、不图强就是灭亡吗？不变法、不图强必然灭亡！变法之中一定会遇到一些问题，可那都不是事。因为不图强就消亡！ 杨锐、林旭、杨深秀：不变化，不生长；不图强，就消亡！ 杨锐：这就是我支持皇上变法的事业！ 林旭：绝望的不是我，绝望的是大清！ 旁白：戊戌政变时，以慈禧太后为首的封建顽固派大肆捕杀维新党人，维新志士谭嗣同、康广仁、林旭、杨深秀、杨锐、刘光第六人于1898年9月28日在北京惨遭杀害，史称“戊戌六君子”。 变法失败了，六君子身死，康、梁仓促出逃，维新派也被打压，几近灭亡。然而，这又何尝不是一种觉醒呢？谭嗣同在狱中写到—— （bgm8《狱中题壁》起） 朗诵：望门投止思张俭，忍死须臾待杜根。我自横刀向天笑，去留肝胆两昆仑。 旁白：在维新派的影响下，无数年轻人觉醒，走上了救亡图存的道路，从改革到革命，从和平到武力，救国的道路越来越宽，终有一天会取得胜利。 （bgm8终）","categories":[{"name":"文学","slug":"文学","permalink":"/categories/文学/"}],"tags":[{"name":"文学","slug":"文学","permalink":"/tags/文学/"},{"name":"剧本","slug":"剧本","permalink":"/tags/剧本/"}],"keywords":[{"name":"文学","slug":"文学","permalink":"/categories/文学/"}]},{"title":"HBCPC河北省赛解题报告","slug":"HBCPC河北省赛解题报告","date":"2019-05-27T07:20:12.000Z","updated":"2019-08-05T01:51:34.242Z","comments":true,"path":"2019/05/27/HBCPC河北省赛解题报告/","link":"","permalink":"/2019/05/27/HBCPC河北省赛解题报告/","excerpt":"之前的游记过于花里胡哨，省赛题解的话另开一个好了 :-） 不知道什么时候能写完以及会写到哪里。 佛系小仙女（其实真相是太菜了，难题是既会写又不会写的~","text":"之前的游记过于花里胡哨，省赛题解的话另开一个好了 :-） 不知道什么时候能写完以及会写到哪里。 佛系小仙女（其实真相是太菜了，难题是既会写又不会写的~ HBCPC河北省赛解题报告封面图是省赛穿的小裙裙QWQ “女装”参赛然后被捶得有点难过。G、K too easy，我就直接跳了。 H.天神的密码 199/528这题也很水。（因为题目给了k的限定，不然就涉及到大整数快速幂）啥也不说了，放个代码。 注意不要使用pow函数计算，pow返回的是double类型，会掉精度。 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { ll n,k; cin&gt;&gt;n&gt;&gt;k; int sum=0; if(k==2) n*=n; while(n) { sum+=n%10; n/=10; } while(sum&gt;=10) { int sum1=sum; sum=0; while(sum1) { sum+=sum1%10; sum1/=10; } } cout&lt;&lt;sum&lt;&lt;endl; } return 0; } &nbsp;当N \\leq 10^{9},K\\leq 500时：因为(10^{9})^{500}只有4500位，使用高精度乘法模拟即可。&nbsp;当N \\leq 10^{1000000}, K\\leq 10^{18}时：考虑这个过程的性质，设某个数N的第i个数位的数字为N[i],可以知道：N \\, mod\\, 9=N[1]10^{k}\\,mod 9+N[2]10^{K-1}\\,mod 9+…+N[k]\\,mod 9=N[1]+N[2]+N[3]+…+N[k]也就是说，对于某个数字N来说，他的所有的数位上的和对9取模等于数字N对9取模。设第i次操作后的值为y_{i},我们可以知道N^K \\, mod \\,9 = y_{1} \\,mod \\,9=y_{2}\\, mod \\,9=y{3}\\,mod\\,9 =…=y_{n} mod \\,9由此，可以得知：题目中对于数字X=N^K进行变换的过程等价于令N^K对9取模,使用快速幂计算即可。 B.icebound and sequence 27/720 S = (\\sum_{i = 1}^{n} \\ q^i) \\ mod \\ p \\ (1 \\leq n,p,q \\leq 10^9) 简单想法直接模拟，复杂度 O(n) ，n 太大会 TLEsolution 1考虑等比数列的性质，如果我们想要计算S=q^{l}+q^{l+1}+\\cdots+q^r，我们可以先计算S’=q^{0}+q^{1}+\\cdots+q^{r-l}，然后整体乘上q^l,即S=S’q^l。利用这个性质，我们使用递归分治法解题。假设递归的这一层我们需要计算 T=(\\sum_{i=1}^b q^i)\\,mod \\,p ，我们先递归计算 T’=(\\sum_{i=1}^{\\lfloor b/2 \\rfloor} q^i)\\,mod \\,p ，将得到的结果乘上1+q^{b}，则得到S=T’(1+q^{b})=q+q^{2}+\\cdots+q^{\\lfloor b/2 \\rfloor2}。因为最后一项为向下取整再乘二，如果b为奇数的时候还需要再加一个q^{b}。全程注意取模！对于每一层我们都像上面那样递归，每一层都需要使用快速幂计算，共有logn层，总复杂度为O(lognlogn)，如果我们每层都记录一个参数Q=q^b，,则无需快速幂，总复杂度为O(logn)solution 2令s[i]表示等比数列前i项的和，则s[i]=s[i-1]*q+q，这是一个线性常系数递推式，可以使用矩阵快速幂处理递推。solution 3根据等比数列求和公式：当p \\neq 1时，S = (\\dfrac {q^{n + 1} - 1} {q - 1} + 1) \\ mod \\ p由于 p 可能为合数，(q -1)在模 p 意义下可能不存在逆元所以要改变一下模数，先将模数改为 p’ = p \\times (q - 1) ，计算模 p’ 意义下的答案 S = a \\times p’ + b ，由于 ，S，a 能被 (q - 1) 整除， 故 b 能被 (q - 1) 整除，就可以不用求逆元 我直接套了邝斌巨巨的板子，快速幂+递归 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll n,MOD,q; ll pow_m(ll a,ll n) { ll ret=1; ll tmp=a%MOD; while(n) { if(n&amp;1) ret=(ret*tmp)%MOD; tmp=tmp*tmp%MOD; n&gt;&gt;=1; } return ret; } ll sum(ll p,ll n) { if(p==0) return 0; if(n==0) return 1; if(n&amp;1) return ((1+pow_m(p,n/2+1))%MOD*sum(p,n/2)%MOD)%MOD; else return ((1+pow_m(p,n/2+1))%MOD*sum(p,n/2-1)+pow_m(p,n/2)%MOD)%MOD; } int main() { int t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;q&gt;&gt;n&gt;&gt;MOD; if(sum(q,n)==0) cout&lt;&lt;MOD-1&lt;&lt;endl; else cout&lt;&lt;sum(q,n)-1&lt;&lt;endl; } return 0; } C.分治 25/171区间 dp用 dp[i][j] 表示攻打完第 i 个国家到第 j 个国家共 (j - i + 1) 个国家需要的最小花费第一层循环枚举区间长度，第二层循环枚举区间左断点，第三层循环枚举最先攻打区间 [i, j] 内的城市k。则状态转移为 dp[i][j] = min { dp[i][k - 1] + dp[k + 1][j] + (j - i) * cost[k] } 复杂度是 O(n^3)&nbsp; #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int dp[105][105]; int cost[105],n; int main() { int t; cin&gt;&gt;t; while(t--) { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;cost[i]; memset(dp,0x3f,sizeof(dp)); for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=2;len&lt;=n;len++) { for(int l=1;l+len&lt;=n+1;l++) { int r=l+len-1; for(int i=l+1;i&lt;=r-1;i++) { dp[l][r]=min(dp[l][r],dp[l][i-1]+dp[i+1][r]+(r-l)*cost[i]); } dp[l][r]=min(dp[l][r],dp[l][l]+dp[l+1][r]+(r-l)*cost[l]); dp[l][r]=min(dp[l][r],dp[r][r]+dp[l][r-1]+(r-l)*cost[r]); } } cout&lt;&lt;dp[1][n]&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"HDU1426 Sudoku Killer（DFS）","slug":"HDU1426-Sudoku-Killer（DFS）","date":"2019-04-02T12:25:50.000Z","updated":"2019-04-02T13:20:03.774Z","comments":true,"path":"2019/04/02/HDU1426-Sudoku-Killer（DFS）/","link":"","permalink":"/2019/04/02/HDU1426-Sudoku-Killer（DFS）/","excerpt":"和数独的不解之缘:D 初三的时候有段时间特别喜欢解数独，大概玩了一个星期就已经能把书里最难的数独题在十分钟以内破解。我觉得数独纯粹是一个推理+解方程的游戏，把所有能明确推理出来的空填上，剩下的只要设一个x就可以解出来，并没有什么奇技淫巧。 回到这道题，我还是有点害怕DFS。不怕不怕，多写写Yisin你一定可以的！吼= =","text":"和数独的不解之缘:D 初三的时候有段时间特别喜欢解数独，大概玩了一个星期就已经能把书里最难的数独题在十分钟以内破解。我觉得数独纯粹是一个推理+解方程的游戏，把所有能明确推理出来的空填上，剩下的只要设一个x就可以解出来，并没有什么奇技淫巧。 回到这道题，我还是有点害怕DFS。不怕不怕，多写写Yisin你一定可以的！吼= = HDU1426 Sudoku Killer（DFS）题目链接&lt;–点这里 自从2006年3月10日至11日的首届数独世界锦标赛以后，数独这项游戏越来越受到人们的喜爱和重视。 据说，在2008北京奥运会上，会将数独列为一个单独的项目进行比赛，冠军将有可能获得的一份巨大的奖品———HDU免费七日游外加lcy亲笔签名以及同hdu acm team合影留念的机会。 所以全球人民前仆后继，为了奖品日夜训练茶饭不思。当然也包括初学者linle，不过他太笨了又没有多少耐性，只能做做最最基本的数独题，不过他还是想得到那些奖品，你能帮帮他吗？你只要把答案告诉他就可以，不用教他是怎么做的。 数独游戏的规则是这样的：在一个9x9的方格中，你需要把数字1-9填写到空格当中，并且使方格的每一行和每一列中都包含1-9这九个数字。同时还要保证，空格中用粗线划分成9个3x3的方格也同时包含1-9这九个数字。比如有这样一个题，大家可以仔细观察一下，在这里面每行、每列，以及每个3x3的方格都包含1-9这九个数字。 Input 本题包含多组测试，每组之间由一个空行隔开。每组测试会给你一个 9*9 的矩阵，同一行相邻的两个元素用一个空格分开。其中1-9代表该位置的已经填好的数，问号（?）表示需要你填的数。 Output 对于每组测试，请输出它的解，同一行相邻的两个数用一个空格分开。两组解之间要一个空行。 对于每组测试数据保证它有且只有一个解。 Sample Input 7 1 2 ? 6 ? 3 5 8 ? 6 5 2 ? 7 1 ? 4 ? ? 8 5 1 3 6 7 2 9 2 4 ? 5 6 ? 3 7 5 ? 6 ? ? ? 2 4 1 1 ? 3 7 2 ? 9 ? 5 ? ? 1 9 7 5 4 8 6 6 ? 7 8 3 ? 5 1 9 8 5 9 ? 4 ? ? 2 3 Sample Output 7 1 2 4 6 9 3 5 8 3 6 5 2 8 7 1 9 4 4 9 8 5 1 3 6 7 2 9 2 4 1 5 6 8 3 7 5 7 6 3 9 8 2 4 1 1 8 3 7 2 4 9 6 5 2 3 1 9 7 5 4 8 6 6 4 7 8 3 2 5 1 9 8 5 9 6 4 1 7 2 3","categories":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"keywords":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}]},{"title":"HDU1584 蜘蛛牌（DFS）","slug":"HDU1584-蜘蛛牌（DFS）","date":"2019-04-02T10:54:57.000Z","updated":"2019-04-02T11:38:58.532Z","comments":true,"path":"2019/04/02/HDU1584-蜘蛛牌（DFS）/","link":"","permalink":"/2019/04/02/HDU1584-蜘蛛牌（DFS）/","excerpt":"听说此题做不出深搜就还没到功夫QAQ 说的可能就是我 这一题乍一看是dp（可以用dp做，但是是数位dp……),还是好好想想DFS怎么做叭，嘤~","text":"听说此题做不出深搜就还没到功夫QAQ 说的可能就是我 这一题乍一看是dp（可以用dp做，但是是数位dp……),还是好好想想DFS怎么做叭，嘤~ HDU1584 蜘蛛牌（DFS）题目链接&lt;–点这里 蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。 Input 第一个输入数据是T，表示数据的组数。 每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。 Output 对应每组数据输出最小移动距离。 Sample Input 1 1 2 3 4 5 6 7 8 9 10 Sample Output 9 我觉得这位巨巨讲的很好，可戳 如果我来讲的话，这道题的关键点和所有DFS一样，就是有个递归过程。那么我们脑动模拟蜘蛛纸牌过程，可以发现这个递归关键点在于要不要先把第i张牌移动到比它大1的数字下方。 需要注意的是，比它大1的数字不一定在一开始的位置，所以需要用一个vis[]数组标记每张牌是否被移动。因为每张牌只能放在比它大1的牌下方，所以如果某张牌被标记为移动，只需要从这张牌往后遍历第一张没有被移动的牌，就是一开始那张牌现在所在的位置。 整个dfs过程我们需要两个变量，num代表已经排好的牌数量，sum代表当前距离和。优化剪枝的地方在于，如果sum&gt;ans(之前搜索到的最小完整sum值)，可以直接return，因为这一定不是最优解。边界条件就是当num==9时，说明我们移动了9张牌，整个蜘蛛纸牌已经有序，需要return，把sum值赋给ans（因为没有被剪枝，所以此时sum一定 &lt; ans,为当前搜索到的最优解。 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int a[15],vis[15],ans; void dfs(int num,int sum) { if(sum&gt;ans) return ; if(num==9) { ans=sum; return; } else { for(int i=1;i&lt;=10;i++) { if(!vis[i]) { vis[i]=1; for(int j=i+1;j&lt;=10;j++) { if(!vis[j]) { dfs(num+1,sum+abs(a[i]-a[j])); break; } } vis[i]=0; //回溯，dfs的关键 } } } } int main() { int t; cin&gt;&gt;t; while(t--) { for(int i=1;i&lt;=10;i++) { int x; cin&gt;&gt;x; a[x]=i; } ans=1000000; dfs(0,0); cout&lt;&lt;ans&lt;&lt;endl; } return 0; }","categories":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"keywords":[{"name":"DFS","slug":"DFS","permalink":"/categories/DFS/"}]},{"title":"密码学之数论基础","slug":"密码学之数论基础","date":"2019-04-01T05:03:06.000Z","updated":"2019-04-01T08:58:27.442Z","comments":true,"path":"2019/04/01/密码学之数论基础/","link":"","permalink":"/2019/04/01/密码学之数论基础/","excerpt":"我爱数学！ 数论是计算机领域的基础，包括ACM、CTF都会用到。我的数学底子一般，曾经参加过数竞培训，但是已经荒废了很久。应用能力比证明能力强。但是我想做踏踏实实走攻数论这条路的人，因为我坚信数学的威力是无穷的。毕竟经济基础决定上层建筑。（大雾）","text":"我爱数学！ 数论是计算机领域的基础，包括ACM、CTF都会用到。我的数学底子一般，曾经参加过数竞培训，但是已经荒废了很久。应用能力比证明能力强。但是我想做踏踏实实走攻数论这条路的人，因为我坚信数学的威力是无穷的。毕竟经济基础决定上层建筑。（大雾） 密码学之数论基础以下内容部分引自境外之王’s blog，感谢~ 素数素数，又叫质数，定义是除了1和它本身以外不再有其他的因数。 整数p&gt;1是素数当且仅当它只有因子+(-)1和+(-)p。 任意整数a&gt;1都可以唯一地因子分解为： 其中p1,p2,…,pt均是素数，p1&lt;p2&lt;…&lt;pt,且所有的ai都是正整数。这就是算术基本定理。 设P是所有素数的集合，则任意正整数a可唯一地表示为： 上式右边是所有素数之积。对某一整数a，其大多数指数ap为0. 两数相乘即是指数对应相加。设，定义k=ab。我们知道整数k可以表示为素数方幂的乘积：。可以推出对于所有的p属于P，有kp=ap+bp成立。 我们通过这个定义，可以写如下程序判断一个数是不是质数 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++){ if(x % i == 0) return false; } return true; } 这个程序的时间复杂度是O(n)，有没有更快的方法，当然 看这个 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)//0.5是防止根号的精度误差 { if(x % i == 0) return false; } return true; } //另一种方法，不需要根号 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)//用乘法避免根号的精度误差 { if(x % i == 0) return false; } return true; } //根据题目不同，如果i*i会爆int，记得开longlong 这个复杂度是O(√n),速度快多了 根据题目不同，有可能你需要先预处理出1~N这N个数是否是素数 如果用刚刚的方法，复杂度就是O(n√n) #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; bool is_prime(int x) { if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++) { if(x % i == 0) return false; } return true; } void init() { for(int i = 0; i &lt; N; i ++) { prime[i] = is_prime(i); } } int main() { init(); } 如果n大一点，就太慢了 介绍一种新方法，埃筛 埃筛————–埃拉托斯特尼筛法，或者叫埃氏筛法 原理：如果找到一个质数，那么这个质数的倍数都不是质数 比如2是质数，那么4,6,8,10,12…都不是质数 然后看3是质数，那么6,9,12,15,18,21…都不是质数 然后看4，4已经被2标记为合数了，所以跳过 然后看5……这样一直筛下去 #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; void init() { for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++) { if(prime[i])//如果i是质数 { for(int j = 2*i; j &lt; N; j += i)//从i的两倍开始的所有倍数 { prime[j] = false; } } } } int main() { init(); } 因为一些数字，比如6既被2的for循环经过又被3的for循环经过，所以复杂度不是O(n) 这个复杂度经过专业人士检验，复杂度O(nloglogn)（学过高数的小朋友可以自己证明≖‿≖✧当然也可以去百度） 知道原理后，我们再稍微优化一下就更快了 #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; void init() { for(int i = 2; i &lt; N; i ++) prime[i] = true; for(int i = 2; i*i &lt; N; i ++)//判断改成i*i&lt;N { if(prime[i]) { for(int j = i*i; j &lt; N; j += i)//从i*i开始就可以了 { prime[j] = false; } } } } int main() { init(); } 快速幂a的b次方怎么求 pow（a, b）是数学头文件math.h里面有的函数 可是它返回值是double类型，数据有精度误差 那就自己写for循环咯 LL pow(LL a, LL b)//a的b次方 { LL ret = 1; for(LL i = 1; i &lt;= b; i ++) { ret *= a; } return ret; } 完美 可是题目是b的范围是1 &lt;= b &lt;= 1e9 超时，妥妥的。。。 看个例子 比如计算 2*2*2*2*2*2*2*2*2*2*2 可以这样算 原式=4*4*4*4*4*2 =8*8*4*2 =16*4*2 你看，相同的可以先合并，减少计算步骤 如果题目说数据很大，还需要求余，那么代码就可以这么写 LL pow_mod(LL a, LL b)//a的b次方 { if(b == 0) return 1; LL ret = pow_mod(a, b/2); ret = ret * ret % MOD; if(b % 2 == 1) ret = ret * a % MOD; return ret; } 这是递归写法 然后还有递推写法 LL pow_mod(LL a, LL b)//a的b次方 { LL ret = 1; while(b != 0) { if(b % 2 == 1) { ret = (ret * a) % MOD ; } a = (a * a ) % MOD ; b /= 2; } return ret; } 对于位运算熟的小盆友，还可以写成位运算形式，速度又快，又好理解，在加一个求余p，代码如下 LL pow_mod(LL a, LL b, LL p)//a的b次方求余p { LL ret = 1; while(b) { if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; } return ret; } 有了快速幂，于是，快速乘诞生了 LL mul(LL a, LL b, LL p)//快速乘，计算a*b%p { LL ret = 0; while(b) { if(b &amp; 1) ret = (ret + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return ret; } 最大公约数gcd和最小公倍数lcmgcd(a, b)，就是求a和b的最大公约数 lcm(a, b)，就是求a和b的最小公倍数 然后有个公式 ab = gcd lcm ( gcd就是gcd(a, b)， ( •̀∀•́ ) 简写你懂吗) 解释（不想看就跳过）{ 首先，求一个gcd，然后。。。 a / gcd 和 b / gcd 这两个数互质了，也就是 gcd( a / gcd ，b / gcd ) = 1，然后。。。 lcm = gcd (a / gcd) (b / gcd) lcm = (a * b) / gcd 所以。。ab = gcd lcm } 所以要求lcm，先求gcd 辣么，问题来了，gcd怎么求 辗转相除法 while循环 LL gcd(LL a, LL b) { LL t; while(b) { t = b; b = a % b; a = t; } return a; } 还有一个递归写法 LL gcd(LL a, LL b) { if(b == 0) return a; else return gcd(b, a%b); } LL gcd(LL a, LL b) { return b ? gcd(b, a%b) : a; } //两种都可以 辣么，lcm = a * b / gcd (注意，这样写法有可能会错，因为a * b可能因为太大 超出int 或者 超出 longlong) 所以推荐写成 ： lcm = a / gcd * b 然后几个公式自己证明一下 gcd(ka, kb) = k * gcd(a, b) lcm(ka, kb) = k * lcm(a, b) 上次做题碰到这个公式 lcm(S/a, S/b) = S/gcd(a, b) S = 9，a = 4，b = 6，小数不会lcm，只好保留分数形式去通分约分。 扩展欧几里德算法度娘百科说： 首先， ax+by = gcd(a, b) 这个公式肯定有解 （( •̀∀•́ )她说根据数论中的相关定理可以证明，反正我信了） 所以 ax+by = gcd(a, b) * k 也肯定有解 （废话，把x和y乘k倍就好了） 所以，这个公式我们写作ax+by = d，(gcd(a, b) | d) gcd(a, b) | d，表示d能整除gcd，这个符号在数学上经常见 那么已知 a，b 求 一组解 x，y 满足 ax+by = gcd(a, b) 这个公式 #include&lt;cstdio&gt; typedef long long LL; void extend_Eulid(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d) { if (!b) {d = a, x = 1, y = 0;} else { extend_Eulid(b, a % b, y, x, d); y -= x * (a / b); } } int main() { LL a, b, d, x, y; while(~scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b)) { extend_Eulid(a, b, x, y, d); printf(&quot;%lld*a + %lld*b = %lld\\n&quot;, x, y, d); } } 有些人喜欢极度简化，这是病，得治(,,• ₃ •,,) void ex_gcd(LL a, LL b, LL &amp;d, LL &amp;x, LL &amp;y) { if(!b){d = a; x = 1; y = 0;} else{ex_gcd(b, a%b, d, y, x); y -= x*(a/b);} } 数论四大定理（提示：以后出现（mod p）就表示这个公式是在求余p的条件下成立） 威尔逊定理当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p ) 或者这么写( p -1 )! ≡ p-1 ( mod p ) 或者说 若p为质数，则p能被(p-1)!+1整除 在初等数论中 这是威尔逊给出了判定一个自然数是否为 素数 的 充分必要条件 但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。(´・ω・`)（威尔逊表示很伤心） 欧拉定理欧拉定理，也称费马-欧拉定理 若n,a为正整数，且n,a互质，即gcd(a,n) = 1，则 a^φ(n) ≡ 1 (mod n) φ(n) 是欧拉函数 欧拉函数是求小于等于n的数中与n互质的数的数目 (o&gt;▽&lt;)太长看不懂？我来帮你断句 欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目 或者说 欧拉函数是求 1到n-1 中 与n互质的数 的数目 如果n是质数 那么1到n-1所有数都是与n互质的， 所以φ(n) = n-1 如果n是合数。。。自己算吧 例如φ(8)=4，因为1,3,5,7均和8互质 顺便一提，这是欧拉定理 φ(n)是欧拉函数 还有一个欧拉公式 eix = cosx + isinx 把x用π带进去，变成 eiπ= -1 大部分人写成 eiπ + 1 = 0 这是一个令万人膜拜的伟大公式 一定要分清 欧拉定理，欧拉函数和欧拉公式这3个东西，要不然你就百度不到你想要的东西了 孙子定理（中国剩余定理）孙子定理，又称中国剩余定理。 公元前后的《孙子算经》中有“物不知数”问题：“今有物不知其数，三三数之余二 ，五五数之余三 ，七七数之余二，问物几何？”答为“23”。 就是说，有一个东西不知道有多少个，但是它求余3等于2，求余5等于3，求余7等于2，问这个东西有多少个？”答为“23”。 用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： 中国剩余定理说明：假设整数m1,m2, … ,mn两两互质，则对任意的整数：a1,a2, … ,an，方程组 (S)有解 剩余类定义比n小的非负整数集合为Zn: Zn={0,1,….,(n-1)} 这个集合被成为剩余类集，或模n的剩余类。更准确地说，Zn中每一个整数都代表一个剩余类，我们可以将模n的剩余类表示为[0],[1],[2],…,[n-1],其中 [r]={a:a是一个整数，a与r模n同余} 在剩余类的所有整数中，我们通常用最小非负整数来代表这个剩余类。寻找与k是模n同余的最小非负整数的过程，称为模n的k约化。 比如：当k=8，n=4时，寻找8 mod4同余的最小非负整数为0，当k=7，n=4时，寻找7 mod4 同余的最小非负整数为3. 笛卡尔积笛卡尔积又叫笛卡尔乘积，是一个叫笛卡尔的人提出来的。简单的说就是两个集合相乘的结果。 举个例子： 集合A={a1,a2,a3} 集合B={b1,b2} 他们的笛卡尔积是 A*B={(a1,b1),(a1,b2),(a2,b1),(a2,b2),(a3,b1),(a3,b2)} 即任意两个元素结合在一起 CRT中国剩余定理(CRT)是数论中最有用的定理之一。CRT说明某一范围内的整数可通过它的一组剩余类来重构，这组剩余类数是对该整数用一组两两互素的整数取模得到的。CRT可有几种不同的表示形式，这里我们给出其中一种最有用的表示形式： 其中mi是两两互素的，即对1&lt;=i,j&lt;=k, i!=j 有gcd(mi,mj)=1。我们可将ZM中的任一整数对应一个k元组，该k元组的元素均在Zmi中，这种对应关系即为： 其中A属于ZM，对于1&lt;=i&lt;=k, ai属于Zmi，且ai=A mod mi。 CRT 说明下列两个断言成立： (1)上面的映射是ZM到笛卡尔积Zm1Zm2….*Zmk的一一对应(称为双射)，也就是说，对任何A，0&lt;=A&lt;=M,有唯一的k元组(a1,a2,…,ak)与之对应，其中0&lt;=ai&lt;mi,并且对任何这样的k元组(a1,a2,…,ak),ZM中有唯一的A与之对应。 (2)ZM中元素上的运算可等价于对应的k元组上的运算，即在笛卡尔积的每一个分量上独立地执行运算。 中国剩余定理的用途之一是，它给出了一种方法，使得模M的大数运算转化到更小的数上来进行运算，当M为150位或150位以上时，这种方法非常有效。 费马小定理假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。 或者说，若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 你看你看你看o(*≧▽≦)ツ，是不是和欧拉定理很像 因为欧拉定理是费马小定理的推广，所以欧拉定理也叫费马-欧拉定理 顺便一提，费马大定理 费马大定理，又被称为“费马最后的定理”，由法国数学家费马提出。 它断言当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。 被提出后，经历多人猜想辩证，历经三百多年的历史，最终在1995年被英国数学家安德鲁·怀尔斯证明。 离散对数大部分摘录于《密码编码学与网络安全》 离散对数是包括Diffie-Hellman密钥交换和数字签名算法(DSA)在内的许多公钥算法的基础。 模n的整数幂 本原根 模算术对数 未完待续QAQ","categories":[{"name":"算法基础","slug":"算法基础","permalink":"/categories/算法基础/"}],"tags":[{"name":"数论","slug":"数论","permalink":"/tags/数论/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"/categories/算法基础/"}]},{"title":"图论入门","slug":"图论入门","date":"2019-03-29T11:40:52.000Z","updated":"2019-03-30T10:55:42.895Z","comments":true,"path":"2019/03/29/图论入门/","link":"","permalink":"/2019/03/29/图论入门/","excerpt":"从今儿起，我就正儿八经地开始更新学习算法的一些心得惹，图论主要参考的是张新华老师的《算法竞赛宝典》。到时候离散数学学到这里以后，我再进行补充吧。现在只能拿着张老师的书照本宣科。 以下绝对是新手友好系列。因为我自己就是一个菜鸡QAQ，走到哪里都是全队最菜。我检讨。 入门内容包括图的基本概念、图的存储结构（邻接数组、邻接表）、深度优先法、广度优先法。","text":"从今儿起，我就正儿八经地开始更新学习算法的一些心得惹，图论主要参考的是张新华老师的《算法竞赛宝典》。到时候离散数学学到这里以后，我再进行补充吧。现在只能拿着张老师的书照本宣科。 以下绝对是新手友好系列。因为我自己就是一个菜鸡QAQ，走到哪里都是全队最菜。我检讨。 入门内容包括图的基本概念、图的存储结构（邻接数组、邻接表）、深度优先法、广度优先法。 图论入门图的基本概念图是一种非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成。数据元素之间是多对多的关系，即网状结构关系。 图可以分为有向图和无向图两类。无向图：任意两个顶点之间的边都是无向边（简而言之就是没有方向的边）；有向图：任意两个顶点之间的边都是有向边（简而言之就是有方向的边）。 需要注意的是，无论是有向图还是无向图，都需要遵循两点限制： 图形不允许自身循环（每个顶点不能构成自环） 任意两顶点之间的边数不能超过1，即边不能重复 以下是图论中一些基本名词概念解释： 完全图：无向图的任意两顶点之间都存在边（有向图为任意两顶点之间都存在双向边） 路径：在图中由一顶点A到另一顶点B经过的所有边。路径长度为经过的边数。 简单路径：路径上的各顶点（除起点、终点）均不互相重复。 回路：路径上的第一个顶点与最后一个顶点重合的简单路径。下图回路有(A,B,C,D,E,A)等等。 连通顶点：无向图中两个存在一条路径的顶点。 连通图：无向图中任意两个顶点皆连通。 强连通顶点：有向图中两个存在双向边的顶点。 强连通图形：有向图中任意两个顶点皆存在双向边。 度：有向图中，内分支度是指其他顶点前往此顶点的边数，外分支度是指此顶点前往其他顶点的边数。 权：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。 图的存储结构邻接数组图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 无向图我们可以设置两个数组，顶点数组为vertex[4]={v0,v1,v2,v3}，边数组arc[4][4]为上图右边这样的一个矩阵。对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点的边。 有向图我们再来看一个有向图样例，如下图所示的左边。顶点数组为vertex[4]={v0,v1,v2,v3}，弧数组arc[4][4]为下图右边这样的一个矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由v1到v0有弧，得到arc[1][0]=1，而v到v没有弧，因此arc[0][1]=0。邻接表由于存在n个顶点的图需要n*n个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。这时，可以考虑使用邻接表表示法来存储图中的数据。 邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。 无向图 从上图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。例如：v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。 对于无向图来说，使用邻接表进行存储也会出现数据冗余的现象。例如上图中，顶点V0所指向的链表中存在一个指向顶点V3的同事，顶点V3所指向的链表中也会存在一个指向V0的顶点。 有向图 若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向的。因此，有向图的邻接表分为出边表和入边表（又称逆邻接表），出边表的表节点存放的是从表头节点出发的有向边所指的尾节点；入边表的表节点存放的则是指向表头节点的某个顶点，如下图所示。 带权图 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可，如下图所示。 深度优先法广度优先法留坑，待填……","categories":[{"name":"图论","slug":"图论","permalink":"/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"图论","slug":"图论","permalink":"/categories/图论/"}]},{"title":"蓝桥杯总结","slug":"蓝桥杯总结","date":"2019-03-28T10:42:34.000Z","updated":"2019-08-05T01:46:04.910Z","comments":true,"path":"2019/03/28/蓝桥杯总结/","link":"","permalink":"/2019/03/28/蓝桥杯总结/","excerpt":"年轻人要多刷题，少水群，才能进Final。 by Kuangbin 其实如果可以的话，我特别不想面对这个结果。省二都排到了中游的位置，这已经不单纯是运气背的问题了……","text":"年轻人要多刷题，少水群，才能进Final。 by Kuangbin 其实如果可以的话，我特别不想面对这个结果。省二都排到了中游的位置，这已经不单纯是运气背的问题了…… 蓝桥杯总结考完出了综合楼，和紫闻、泽铭一对答案，我就知道我要凉。特别是中位数那题他们的答案是42，我愣了，我写的是三位数——忽然惊醒——题目要求中位数的中位数，我求成了中位数的和。 以及后来看到群里填空最后一空他们是18位，而我大概只有16位，但是我确信我的e都已经求正确了，只不过最后的快速幂写不出来，用的方法大概错了。而大家都会的迷宫bfs，我不会。考前就一直在祈祷，不要出搜索题，遇搜索必死。 大题第二题以后我基本就是争取过几个点，最后一题连题目都没读懂。而且简单的二叉树我好像忘记考虑最大值为负的情况了。 大概是迎面一桶冷水的感觉。虽然不知道CCCC选拔赛的时候自己明明已经好久没碰过算法却出乎意料地稳，但是蓝桥杯展现出来的，才是我真实的水平吧。连我自己都不敢承认的失败。 不想说失败是成功之母。如果可以，谁不想顺顺利利的，谁愿意历经无数次失败还在憧憬成功的曙光？但是失败了，面对失败，找到失败的原因，这个的确是一个loser需要做的事情。 这次出现失误的原因总结： 基础不扎实。像dfs、bfs、dp、快速幂等基础题本来寒假就应该巩固好，但是我自己寒假偷懒只学了STL，导致一大片知识还有盲区。以及离开板子就会丧失好多题目的解题。 开学以来对算法的训练非常少。cf打的次数屈指可数。虽说cf也不是评判的唯一标准，但是题目写的少是事实。 赛场上读题大意，遇到不返回实时结果的情况手足无措。 备战六月份的女生赛，我觉得自己这段时间是该好好收收心，多刷题，少水群。至少这一个月要快速把搜索、dp拿下，剩下的时间看看数论相关知识。还有英语能力的提高。 我本可以忍受黑暗，如果没有见过光明。寒假前我有机会放弃竞赛，但是遇到了wls一干人后，我选定了继续下去的路。我希望，蓝桥杯能留给我一个很深刻的教训，也希望明年此时，我不会再次抱憾归来。","categories":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}]},{"title":"天梯赛选拔Day1","slug":"天梯赛选拔Day1","date":"2019-03-18T05:15:14.000Z","updated":"2019-08-05T01:47:52.795Z","comments":true,"path":"2019/03/18/天梯赛选拔Day1/","link":"","permalink":"/2019/03/18/天梯赛选拔Day1/","excerpt":"心之所向，素履以往；生如逆旅，一苇以航 3月15日接到16、17两天连续选拔赛的消息的时候整个人是慌的，因为从开学到现在都没有怎么写过代码。那晚连散人直播《最强大~脑》都不看了，在宿舍里焦躁地徘徊，一直跟小姐姐说我不行的。最后熬夜又刷了PAT上几道题试图平复心情。 3月16日上午我整理了《All Things About STL》这篇博文，来复习STL基础的操作类型。时间有限，也没能好好看完。 和学姐一起走到科技楼的时候，我一遍又一遍想不要害怕，得之我幸，失之我命，水平决定一切。但比赛开始的时候我还是手忙脚乱，不断出错，而且浏览器似乎有些奇奇怪怪的问题，动不动就崩。等我写完第一题的时候，已经排到了三四十名的位置。换在平时训练赛，这是完全不可能的事情。好在PAT机制下不算错误率和时间，所以一开始的失利并没有太影响到我。之后每写完一题就前进一些，到第八题写完，已经回到第五差不多的位置了。 最后的成绩： 接下来带来题解，前十题我会用自己的方法（+大佬做法）讲，后五题我用大佬做法讲（+教泥萌怎么蒙）。","text":"心之所向，素履以往；生如逆旅，一苇以航 3月15日接到16、17两天连续选拔赛的消息的时候整个人是慌的，因为从开学到现在都没有怎么写过代码。那晚连散人直播《最强大~脑》都不看了，在宿舍里焦躁地徘徊，一直跟小姐姐说我不行的。最后熬夜又刷了PAT上几道题试图平复心情。 3月16日上午我整理了《All Things About STL》这篇博文，来复习STL基础的操作类型。时间有限，也没能好好看完。 和学姐一起走到科技楼的时候，我一遍又一遍想不要害怕，得之我幸，失之我命，水平决定一切。但比赛开始的时候我还是手忙脚乱，不断出错，而且浏览器似乎有些奇奇怪怪的问题，动不动就崩。等我写完第一题的时候，已经排到了三四十名的位置。换在平时训练赛，这是完全不可能的事情。好在PAT机制下不算错误率和时间，所以一开始的失利并没有太影响到我。之后每写完一题就前进一些，到第八题写完，已经回到第五差不多的位置了。 最后的成绩： 接下来带来题解，前十题我会用自己的方法（+大佬做法）讲，后五题我用大佬做法讲（+教泥萌怎么蒙）。 天梯赛选拔Day17-1 到底有多二 （15 分)一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字-13142223336是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。 输入格式： 输入第一行给出一个不超过50位的整数N。 输出格式： 在一行中输出N犯二的程度，保留小数点后两位。 输入样例： -13142223336 输出样例： 81.82% 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 先阐明一个小学数学老师经常强调的点：x增加0.5倍 == x 1.5；x增加1倍 == x 2（well，这里应该也不会有人错）。 单纯找2的话只需要把数据当成字符串读入，寻找2的个数；由于题目同时要求判断是否负数和偶数，还需要对字符串首位和末位进行判断。 窝的代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { //ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int ans=0,flag1=0,flag2=0; int n=s.size(); for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;-&#39;) { flag1=1; n--; continue; } if(s[i]==&#39;2&#39;) ans++; if(i==s.size()-1&amp;&amp;(s[i]-&#39;0&#39;)%2==0) flag2=1; } //cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;endl; double m=ans*100.0/n; //cout&lt;&lt;m&lt;&lt;endl; if(flag1==1) m*=1.5; if(flag2==1) m*=2; printf(&quot;%.2f&quot;,m); cout&lt;&lt;&quot;%&quot;&lt;&lt;endl; return 0; } 有一点需要额外注意，如果取消流同步（ios::sync_with_stdio(false)）了以后输出千万不能cout和printf混用，不然……答案全部错误。刚开始吓傻窝了，还好从前遇到过，还请教过学长萌QWQ 7-2 大笨钟 （10 分)微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。 下面就请你写个程序，根据当前时间替大笨钟敲钟。 输入格式： 输入第一行按照hh:mm的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。 输出格式： 根据当前时间替大笨钟敲钟，即在一行中输出相应数量个Dang。如果不是敲钟期，则输出： Only hh:mm. Too early to Dang. 其中hh:mm是输入的时间。 输入样例1： 19:05 输出样例1： DangDangDangDangDangDangDangDang 输入样例2： 07:05 输出样例2： Only 07:05. Too early to Dang. 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 水题~分类讨论就行 代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int h=(s[0]-&#39;0&#39;)*10+(s[1]-&#39;0&#39;); int m=(s[3]-&#39;0&#39;)*10+(s[4]-&#39;0&#39;); if(h&lt;12) cout&lt;&lt;&quot;Only &quot;&lt;&lt;s&lt;&lt;&quot;. Too early to Dang.&quot;&lt;&lt;endl; else if(h==12&amp;&amp;m==0) cout&lt;&lt;&quot;Only &quot;&lt;&lt;s&lt;&lt;&quot;. Too early to Dang.&quot;&lt;&lt;endl; else { if(m==0) { for(int i=0;i&lt;h-12;i++) cout&lt;&lt;&quot;Dang&quot;; } else { for(int i=0;i&lt;=h-12;i++) cout&lt;&lt;&quot;Dang&quot;; } } return 0; } 7-3 谁先倒 （15 分)划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。 输入格式： 输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为： 甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式： 在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。 输入样例： 1 1 6 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 15 1 1 16 输出样例： A 1 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 我先提供一份最开始只得了4分的错误代码，泥萌找找哪里有问题 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int a1[105],a2[105],b1[105],b2[105]; int main() { ios::sync_with_stdio(false); int a,b,n,ans1=0,ans2=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; for(int i=0;i&lt;n;i++) { if(ans1==a||ans2==b) break; cin&gt;&gt;a1[i]&gt;&gt;a2[i]&gt;&gt;b1[i]&gt;&gt;b2[i]; int m=a1[i]+b1[i]; if(a2[i]==m) ans1++; if(b2[i]==m) ans2++; } if(ans1==a) cout&lt;&lt;&#39;A&#39;&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl; else cout&lt;&lt;&#39;B&#39;&lt;&lt;endl&lt;&lt;ans1&lt;&lt;endl; return 0; } 相信（jia she）泥萌已经发现了，理解题意的重要性。 问题出在下面这几行 if(a2[i]==m) ans1++; if(b2[i]==m) ans2++; 而题目中说：谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮 也就是说，不仅需要满足一人输，还需要满足另一个人嬴。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int a1[105],a2[105],b1[105],b2[105]; int main() { ios::sync_with_stdio(false); int a,b,n,ans1=0,ans2=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a1[i]&gt;&gt;a2[i]&gt;&gt;b1[i]&gt;&gt;b2[i]; } for(int i=0;i&lt;n;i++) { if(ans1&gt;a||ans2&gt;b) break; int m=a1[i]+b1[i]; if(a2[i]==m&amp;&amp;b2[i]!=m) ans1++; if(b2[i]==m&amp;&amp;a2[i]!=m) ans2++; } if(ans1&gt;a) cout&lt;&lt;&#39;A&#39;&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl; else cout&lt;&lt;&#39;B&#39;&lt;&lt;endl&lt;&lt;ans1&lt;&lt;endl; return 0; } 7-4 帅到没朋友 （20 分)当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。 输入格式： 输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。 注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。 输出格式： 按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。 注意：同一个人可以被查询多次，但只输出一次。 输入样例1： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 8 55555 44444 10000 88888 22222 11111 23333 88888 输出样例1： 10000 88888 23333 输入样例2： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 4 55555 44444 22222 11111 输出样例2： No one is handsome 时间限制: 250 ms 内存限制: 64 MB 代码长度限制: 16 KB 照例先放错误代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); map&lt;string,int&gt;mp,mp2; queue&lt;string&gt;q; int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; while(m--) { string s; cin&gt;&gt;s; mp[s]++; } } int p; cin&gt;&gt;p; while(p--) { string s; cin&gt;&gt;s; if(mp2[s]==0) { if(mp[s]==0) q.push(s); } mp2[s]++; } if(q.empty()) cout&lt;&lt;&quot;No one is handsome&quot;&lt;&lt;endl; else { while(!q.empty()) { if(q.size()==1) cout&lt;&lt;q.front()&lt;&lt;endl; else cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;; q.pop(); } } return 0; } 又是没好好读题的锅~ 没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。也就是说，k=1的时候和没有k的时候没区别啊。wsl~ 这道题我用了queue+map（其实可以不用queue，直接在线查询就行）。map的思路就是：当k&gt;1时，把后面所有编号纳入map，之后查询的时候只要看看map的值是否为0就行。还要注意：同一个人可以被查询多次，但只输出一次。所以要再用一个map记录是否已经被查询过。当然这道题的编号并不大，用数组也ok，就是注意输出要把前导0补全。 AC代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); map&lt;string,int&gt;mp,mp2; queue&lt;string&gt;q; int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { string s; cin&gt;&gt;s; if(m&gt;1) mp[s]++; } } int p; cin&gt;&gt;p; while(p--) { string s; cin&gt;&gt;s; if(mp2[s]==0) { if(mp[s]==0) q.push(s); } mp2[s]++; } if(q.empty()) cout&lt;&lt;&quot;No one is handsome&quot;&lt;&lt;endl; else { while(!q.empty()) { if(q.size()==1) cout&lt;&lt;q.front()&lt;&lt;endl; else cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;; q.pop(); } } return 0; } 7-5 重要的话说三遍 （5 分)7-6 奇偶分家 （10 分)//5、6两道zz题窝就直接跳了= = 7-7 输出GPLT （20 分)给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按GPLTGPLT….这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按GPLT的顺序打印，直到所有字符都被输出。 输入格式： 输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。 输出格式： 在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例： pcTclnGloRgLrtLhgljkLhGFauPewSKgt 输出样例： GPLTGPLTGLTGLGLL 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 这道题纯暴力。本来想看看网上有没有什么大佬的巧妙解法，发现只能模拟。这道题题意可以转换到分别统计GPLT个数，然后依次输出。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int ans1=0,ans2=0,ans3=0,ans4=0; for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;G&#39;||s[i]==&#39;g&#39;) ans1++; if(s[i]==&#39;P&#39;||s[i]==&#39;p&#39;) ans2++; if(s[i]==&#39;L&#39;||s[i]==&#39;l&#39;) ans3++; if(s[i]==&#39;T&#39;||s[i]==&#39;t&#39;) ans4++; } int m=max(max(ans1,ans2),max(ans3,ans4)); while(m--) { if(ans1&gt;0) { cout&lt;&lt;&#39;G&#39;; ans1--; } if(ans2&gt;0) { cout&lt;&lt;&#39;P&#39;; ans2--; } if(ans3&gt;0) { cout&lt;&lt;&#39;L&#39;; ans3--; } if(ans4&gt;0) { cout&lt;&lt;&#39;T&#39;; ans4--; } } return 0; } 7-8 后天 （5 分)//又是水题~跳鸭 7-9 抢红包 （25 分)没有人没抢过红包吧…… 这里给出N个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。 输入格式： 输入第一行给出一个正整数N（≤10^​4），即参与发红包和抢红包的总人数，则这些人从1到N编号。随后N行，第i行给出编号为i的人发红包的记录，格式如下： K N1 P​1 ⋯NK P​K 其中K（0≤K≤20）是发出去的红包个数，Ni是抢到红包的人的编号，Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。 输出格式： 按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。 输入样例： 10 3 2 22 10 58 8 125 5 1 345 3 211 5 233 7 13 8 101 1 7 8800 2 1 1000 2 1000 2 4 250 10 320 6 5 11 9 22 8 33 7 44 10 55 4 2 1 3 8800 2 1 23 2 123 1 8 250 4 2 121 4 516 7 112 9 10 输出样例： 1 11.63 2 3.63 8 3.63 3 2.11 7 1.69 6 -1.67 9 -2.18 10 -3.26 5 -3.26 4 -12.32 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 用个结构体排序就好惹，不多说，直接上代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; struct p { int num,money,n; }s[100005]; bool cmp(p a,p b) { if(a.money==b.money) { if(a.n==b.n) return a.num&lt;b.num; return a.n&gt;b.n; } return a.money&gt;b.money; } int main() { //ios::sync_with_stdio(false); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { s[i].num=i; int m,sum=0; cin&gt;&gt;m; while(m--) { int c,d; cin&gt;&gt;c&gt;&gt;d; s[c].n++; s[c].money+=d; sum+=d; } s[i].money-=sum; } sort(s+1,s+n+1,cmp); for(int i=1;i&lt;=n;i++) { cout&lt;&lt;s[i].num&lt;&lt;&quot; &quot;; printf(&quot;%.2f\\n&quot;,s[i].money/100.0); } return 0; } 7-10 排座位 （25 分)布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。 输入格式： 输入第一行给出3个正整数：N（≤100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：宾客1 宾客2 关系，其中关系为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。 这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。 输出格式： 对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出No problem；如果他们之间并不是朋友，但也不敌对，则输出OK；如果他们之间有敌对，然而也有共同的朋友，则输出OK but…；如果他们之间只有敌对关系，则输出No way。 输入样例： 7 8 4 5 6 1 2 7 -1 1 3 1 3 4 1 6 7 -1 1 2 1 1 4 1 2 3 -1 3 4 5 7 2 3 7 2 输出样例： No problem OK OK but... No way 时间限制: 150 ms 内存限制: 64 MB 代码长度限制: 16 KB 其实我拿到这题的第一反应是并——查——集——！！！？？？！！！ 寒假虽然练过并查集的题目，但是没有板子的话就不知道能不能写了。但是并查集的算法原理我是知道的，所以抱着那一丝丝希望，而且如果我写不出来必然会从排行榜跌下去，窝就果断开始写。 首先我们可以把判读敌人和朋友的方法区别开。朋友我采用的是并查集（因为涉及朋友的朋友也是朋友）；敌人我采用的是结构体内部嵌套数组，标记是否直接敌对（只有单纯直接的敌对关系才是绝对不能同席的）。 我的AC代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int father[105]; struct diren { int s[105]; }q[105]; void init(int n) { for(int i=1;i&lt;=n;i++) { father[i]=i; } } int find_father(int n) { if(father[n]==n) return n; else { return find_father(father[n]); } } void Union(int a,int b) { if(a&gt;b) swap(a,b); father[b]=a; } int main() { ios::sync_with_stdio(false); int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; init(n); while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(c==1) { Union(a,b); } else { q[a].s[b]=1; q[b].s[a]=1; } } while(k--) { int a,b; cin&gt;&gt;a&gt;&gt;b; if(q[a].s[b]==1 &amp;&amp; find_father(a)!=find_father(b)) cout&lt;&lt;&quot;No way&quot;&lt;&lt;endl; else if(q[a].s[b]==1) cout&lt;&lt;&quot;OK but...&quot;&lt;&lt;endl; else if(find_father(a)==find_father(b)) cout&lt;&lt;&quot;No problem&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; } return 0; } 但是由于我的并查集是自己靠着理解瞎想的，并不标准，所以接下来推荐大佬代码（所以我为啥不用二维数组要用结构体内嵌数组……我傻了)。 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int pre[101]; int map[101][101]; //邻接矩阵存储两者的直接关系，1朋友 -1敌对 int find(int x){ //寻找 int r = x; while(pre[r]!=r){ r = pre[r]; } int i=x ,j; while(pre[i]!=r){ //路径压缩 j = pre[i]; pre[i] = r; i = j; } return r; } void join(int x,int y){ //将两个集合合并 int fx = find(x); int fy = find(y); if(fx!=fy){ pre[fx] = fy; } } bool same(int x,int y){ //判断两个元素是否在同一个集合中 if(find(x)==find(y)){ return true; }else{ return false; } } int main(){ int n,m,a,b,c,t; cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; for(int i=1 ;i&lt;=n ;i++){ pre[i] = i; } for(int i=1 ;i&lt;=m ;i++){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); map[a][b] = c; //记录直接的对应关系 map[b][a] = c; if(c==1){ join(a,b); //间接的朋友关系 } } for(int i=1 ;i&lt;=t; i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(map[a][b]==1){ printf(&quot;No problem\\n&quot;); } else if(map[a][b]==-1&amp;&amp;find(a)==find(b)){ printf(&quot;OK but...\\n&quot;); } else if(map[a][b]==-1&amp;&amp;find(a)!=find(b)){ printf(&quot;No way\\n&quot;); } else if(map[a][b]!=-1&amp;&amp;map[a][b]!=1&amp;&amp;find(a)!=find(b)){ printf(&quot;OK\\n&quot;); } } return 0; } 7-11 玩转二叉树 （25 分)给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。 输出格式： 在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例： 7 1 2 3 4 5 6 7 4 1 3 2 6 5 7 输出样例： 4 6 1 7 5 3 2 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 作为一个二叉树盲，大致扫了一下网上题解发现非常不适合入门级别选手。所以额外找了二叉树的知识点整理一下。(转自指点的专栏) 这棵二叉树一共有7个节点，其中，0号节点叫做根节点，下面的1号节点和2号节点是0号节点的子节点，同时1号节点和2号节点又是3号节点、4号节点和5号节点、6号节点的双亲节点，0号节点有分别以1号节点和2号节点作为根节点的左右子树。5号节点和6号节点没有子节点（子树），那么它们被称为叶子节点。 一般来说，二叉树常用的遍历方式有：前序遍历、中序遍历、后序遍历、层序遍历 四种遍历方式： 1、前序遍历二叉树顺序：根节点 –&gt; 左子树 –&gt; 右子树，即先访问根节点，然后是左子树，最后是右子树。 上图中二叉树的前序遍历结果为：0 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 2、中序遍历二叉树顺序：左子树 –&gt; 根节点 –&gt; 右子树，即先访问左子树，然后是根节点，最后是右子树。 上图中二叉树的中序遍历结果为：3 -&gt; 1 -&gt; 4 -&gt; 0 -&gt; 5 -&gt; 2 -&gt; 6 3、后续遍历二叉树顺序：左子树 –&gt; 右子树 –&gt; 根节点，即先访问左子树，然后是右子树，最后是根节点。 上图中二叉树的后序遍历结果为：3 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 6 -&gt; 2 -&gt; 0 4、层序遍历二叉树顺序：从最顶层的节点开始，从左往右依次遍历，之后转到第二层，继续从左往右遍历，持续循环，直到所有节点都遍历完成 上图中二叉树的层序遍历结果为：0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 下面给出这四种算法思想的伪代码： 前序遍历： preOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 preOrderParse(tree[n].leftChild); // 递归输出左子树 preOrderParse(tree[n].rightChild); // 递归输出右子树 } 中序遍历： inOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 inOrderParse(tree[n].leftChild); // 递归输出左子树 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 inOrderParse(tree[n].rightChild); // 递归输出右子树 } 后续遍历： pastOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 pastOrderParse(tree[n].leftChild); // 递归输出左子树 pastOrderParse(tree[n].rightChild); // 递归输出右子树 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 } 可以看到前三种遍历都是直接通过递归来完成，用递归遍历二叉树简答方便而且好理解，接下来层序遍历就需要动点脑筋了，我们如何将二叉树一层一层的遍历输出？其实在这里我们要借助一种数据结构来完成：队列。 我们都知道，队列是一种先进先出的数据结构，我们可以先将整颗二叉树的根节点加入队尾，然后循环出队，每次读取队头元素输出并且将队头元素出队，然后将这个输出的元素节点的的左右子树分别依次加入队尾，重复这个循环，知道队列为空的时候结束输出。那么整个二叉树就被我们采用层序遍历的思想输出来了。下面我们看一下上图的二叉树用层序遍历思想的遍历步骤： while(!que.empty()) { int n = que.front(); // 得到队头元素 que.pop(); // 队头元素出队列 // 如果当前节点不为空，那么输出节点的数值，并且在队尾插入左右子节点 if(tree[n] != NULL) { cout &lt;&lt; tree[n].w; que.push(tree[n].leftChild); que.push(tree[n].rightChild); } } Ok，下面来看一下这几个遍历算法的最终代码： /* * 二叉树的四种遍历方式，这里没有采用真实的指针去做， * 而是采用数组下标去模拟指针，是一种更加方便快速的方法 */ #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; const int N = 10010; const int INF = -1; //我们用一个常数来表示当前二叉树节点为空的情况 struct Node { int w; // 当前树节点的值 int p; // 当前树节点的双亲所在数组下标 int l; // 当前树节点的左子节点所在数组下标 int r; // 当前树节点的右子节点所在数组下标 }; Node node[N]; // 按照前序遍历二叉树的顺序输入树节点 void input(int n) { cin &gt;&gt; node[n].w; if(node[n].w == INF) //输入-1代表当前节点所在子二叉树停止输入 { return ; } node[n].p = n / 2; node[n].l = n * 2; node[n].r = n * 2 + 1; input(n*2); input(n*2+1); } // 前序遍历二叉树 void preOrderParse(int n) { if(node[n].w == INF) { return ; } cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; preOrderParse(node[n].l); preOrderParse(node[n].r); } // 中序遍历二叉树 void inOrderParse(int n) { if(node[n].w == INF) { return ; } inOrderParse(n*2); cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; inOrderParse(n*2+1); } // 后续遍历二叉树 void postOrderParse(int n) { if(node[n].w == INF) { return ; } postOrderParse(n*2); postOrderParse(n*2+1); cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; } /* * 层序遍历二叉树，这里采用的是 C++ STL 模板的提供的队列(queue)， * 并没有自己去实现一个队列 */ void sequenceParse() { queue&lt;int&gt; que; int n = 1; que.push(1); // 插入根节点所在数组下标 while(!que.empty()) { n = que.front(); que.pop(); // 得到队头元素并且将队头元素出队列 // 如果当前节点不为空，那么输出该节点，并且将该节点的左右子节点插入队尾 if(node[n].w != INF) { cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; que.push(node[n].l); que.push(node[n].r); } } } int main() { cout &lt;&lt; &quot;请以前序遍历的顺序输入二叉树，空节点输入 -1 ：&quot; &lt;&lt; endl; input(1); // 从下标为 1 开始前序输入二叉树 cout &lt;&lt; &quot;前序遍历：&quot; &lt;&lt; endl; preOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;中序遍历：&quot; &lt;&lt; endl; inOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;后序遍历：&quot; &lt;&lt; endl; postOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;层序遍历：&quot; &lt;&lt; endl; sequenceParse(); return 0; } 然后回到原题，大体思路就是根据前序、中序序列还原建树，然后镜面反转，就是将非叶子节点的左右孩子互换，最后层序遍历输出这棵树。","categories":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"},{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}]},{"title":"All Things About STL","slug":"All-Things-About-STL","date":"2019-03-16T00:44:04.000Z","updated":"2019-08-05T01:44:37.484Z","comments":true,"path":"2019/03/16/All-Things-About-STL/","link":"","permalink":"/2019/03/16/All-Things-About-STL/","excerpt":"STL nb！ These violent delights have violent ends. And in their triumph die, like fire and powder, Which, as they kiss, consume.","text":"STL nb！ These violent delights have violent ends. And in their triumph die, like fire and powder, Which, as they kiss, consume. All Things About STL大家好，我是废话 快速了解STLSTL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。(引自百度百科。一堆废话。） STL之Stack(堆栈)堆栈是一个线性表，插入和删除只在表的一端进行。这一端称为栈顶(Stack Top)，另一端则为栈底(Stack Bottom)。堆栈的元素插入称为入栈，元素的删除称为出栈。由于元素的入栈和出栈总在栈顶进行，因此，堆栈是一个后进先出(Last In First Out)表，即 LIFO 表。C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。为了严格遵循堆栈的数据后进先出原则，stack 不提供元素的任何迭代器操作，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。stack堆栈容器的C++标准头文件为 stack ，必须用宏语句 “#include “ 包含进来，才可对 stack 堆栈的程序进行编译。 Stack的成员函数 empty() 堆栈为空则返回真 pop() 移除栈顶元素 push() 在栈顶增加元素 size() 返回栈中元素数目 top() 返回栈顶元素 STL之queue（队列）先进先出（FIFO），即插入和删除操作分别在位的不同端。插入元素的那一端为队尾，删除元素的那一端为队首。 queue的成员函数 back() 返回最后一个元素 empty() 如果队列空则返回真 front() 返回第一个元素 pop() 删除第一个元素 push() 在末尾加入一个元素 size() 返回队列中元素的个数 STL之priority queue（优先队列）优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。 priority queue的成员函数基本操作： empty() 如果队列为空，则返回真 pop() 删除对顶元素，删除第一个元素 push() 加入一个元素 size() 返回优先队列中拥有的元素个数 top() 返回优先队列对顶元素，返回优先队列中有最高优先级的元素 在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。 自定义优先级： //定义结构，使用运算符重载,自定义优先级1 struct cmp1 { bool operator ()(int &amp;a,int &amp;b) { return a&gt;b;//最小值优先 } }; struct cmp2 { bool operator ()(int &amp;a,int &amp;b) { return a&lt;b;//最大值优先 } }; //定义结构，使用运算符重载,自定义优先级2 struct number1 { int x; bool operator &lt; (const number1 &amp;a) const { return x&gt;a.x;//最小值优先 } }; struct number2 { int x; bool operator &lt; (const number2 &amp;a) const { return x&lt;a.x;//最大值优先 } }; priority_queue&lt;int&gt;que;//采用默认优先级构造队列 priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt;que1;//最小值优先 riority_queue&lt;int,vector&lt;int&gt;,cmp2&gt;que2;//最大值优先 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;que3;//注意“&gt;&gt;”会被认为错误，这是右移运算符，所以这里用空格号隔开 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;que4;//最大值优先 priority_queue&lt;number1&gt;que5; priority_queue&lt;number2&gt;que6; 在优先队列中使用结构体的若干小结以结构体Time为例： struct Time { int start, end; }; 使用优先队列时，如果需要对Time中的start从小到大排序，有两种方法： priority_queue&lt;Time&gt; pq; 一.在结构体外重载结构体小于运算符： bool operator &lt;(const Time&amp; a,const Time&amp; b) { return a.start &gt; b.start; } //这里以大于重载小于是因为默认情况下，优先队列是以大的作为队首，这样一反，就可以再默认情况下使得小的作为队首 二.直接在结构体中重载小于运算符： struct Time { int start, end; bool operator &lt; (const Time&amp; t)const { return start &gt; t.start; } }; 实质上来说是一样的。。。。 另外要注意的是：参数列表中的const不能省略，否则报错~~ STL之deque（双端队列）deque与vector非常相似，不仅可以在尾部插入和删除元素，还可以在头部插入和删除。不过当考虑到容器元素的内存分配策略和操作性能时，deque相对vector较为有优势。 deque的成员函数 [ ]：用来访问双向队列中单个的元素。 front()：返回第一个元素的引用。 back()：返回最后一个元素的引用。 push_front(x)：把元素x插入到双向队列的头部。 pop_front()：弹出双向队列的第一个元素。 push_back(x)：把元素x插入到双向队列的尾部。 pop_back()：弹出双向队列的最后一个元素。 STL之vector（引自@博客园_清水汪汪） vector是表示可变大小数组的序列容器。 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。 vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。 与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。 vector的成员函数 容量 向量大小： vec.size(); 向量最大容量： vec.max_size(); 更改向量大小： vec.resize(); 向量真实大小： vec.capacity(); 向量判空： vec.empty(); 减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //shrink_to_fit 修改 多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值 末尾添加元素： vec.push_back(); 末尾删除元素： vec.pop_back(); 任意位置插入元素： vec.insert(); 任意位置删除元素： vec.erase(); 交换两个向量的元素： vec.swap(); 清空向量元素： vec.clear(); 迭代器 开始指针：vec.begin(); 末尾指针：vec.end(); //指向最后一个元素的下一个位置 指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾指针： vec.cend(); 元素的访问 下标访问： vec[1]; //并不会检查是否越界 at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常 访问第一个元素： vec.front(); 访问最后一个元素： vec.back(); 返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。 算法 遍历元素vector&lt;int&gt;::iterator it; for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; //或者 for (size_t i = 0; i &lt; vec.size(); i++) { cout &lt;&lt; vec.at(i) &lt;&lt; endl; } 元素翻转#include &lt;algorithm&gt; reverse(vec.begin(), vec.end()); 元素排序#include &lt;algorithm&gt; sort(vec.begin(), vec.end()); //采用的是从小到大的排序 //如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法: bool Comp(const int&amp; a, const int&amp; b) { return a &gt; b; } sort(vec.begin(), vec.end(), Comp); STL之vector,deque对比(引自@开源中国_爱吃冰红茶)vector,deuqe之对比： 随机访问速度：vector &gt; deque。 deque性能损失比vector高几个数量级：因为deque首次插入一个元素时，会默认动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后虚拟地连在一起。deque的这种设计使得它具有比vector复杂得多的架构、算法和迭代器设计，也使得性能损失比vector高！ 在插入删除操作时，deque由于vector:对于vector而言，由于其是一端开口，所以在尾部插入耗费固定的时间，而在头部进行插入时，耗费的时间与vector的大小成正比，vector越大，耗费的时间越多。而对于deque,不管插入删除操作是在头部还是尾部进行，算法的效率是固定的。 可以得到，在vector和deque进行插入删除时，deque的效率是高于vector的。当都是在末尾进行插入时，vector和deque的差别不大，但是在对头部进行插入时，差距十分明显。 总结一下：当进行插入删除时候，选择deque，当进行顺序访问时，选择vector。 STL之listList是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件。 list的成员函数 Lst1.assign() ：给list赋值 Lst1.back() ：返回最后一个元素 Lst1.begin() ：返回指向第一个元素的迭代器 Lst1.clear() ：删除所有元素 Lst1.empty() ：如果list是空的则返回true Lst1.end() ：返回末尾的迭代器 Lst1.erase() ：删除一个元素 Lst1.front() ：返回第一个元素 Lst1.get_allocator() ：返回list的配置器 Lst1.insert() ：插入一个元素到list中 Lst1.max_size() ：返回list能容纳的最大元素数量 Lst1.merge() ：合并两个list Lst1.pop_back() ：删除最后一个元素 Lst1.pop_front() ：删除第一个元素 Lst1.push_back() ：在list的末尾添加一个元素 Lst1.push_front() ：在list的头部添加一个元素 Lst1.rbegin() ：返回指向第一个元素的逆向迭代器 Lst1.remove() ：从list删除元素 Lst1.remove_if() ：按指定条件删除元素 Lst1.rend() ：指向list末尾的逆向迭代器 Lst1.resize() ：改变list的大小 Lst1.reverse() ：把list的元素倒转 Lst1.size() ：返回list中的元素个数 Lst1.sort() ：给list排序 Lst1.splice() ：合并两个list Lst1.swap() ：交换两个list Lst1.unique() ：删除list中重复的元素 遍历List for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++) { cout&lt;&lt;*iter; } cout&lt;&lt;endl; STL之mapMap是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。 容器中元素的访问 下标访问 和访问数组一样。map中键是唯一的 迭代器访问 map&lt; typename1 , typename2 &gt;::iterator it; #include&lt;stdio.h&gt; #include&lt;map&gt; using namespace std; int main() { map&lt;char,int&gt; mp; mp[&#39;a&#39;]=5; mp[&#39;b&#39;]=10; mp[&#39;d&#39;]=40; mp[&#39;c&#39;]=20; mp[&#39;c&#39;]=30;//20被覆盖 printf(&quot;%d\\n&quot;,mp[&#39;c&#39;]); for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); //it-&gt;first:当前映射的键，it-&gt;second:当前映射的值 } //a 5 //b 10 //c 30 //d 40 //map会以键从小到大的顺序自动排序。map内部是使用红黑树实现的，set内部也是。 //建立映射的时候，会自动实现从小到大的排序功能 return 0; } map的成员函数 find() find(key)：返回键为key的映射，时间复杂度为O(logN) erase() 删除单个元素 mp.erase(it)：it为需要删除的元素的迭代器。时间复杂度为O(1) mp.erase(key):key为删除元素的键，时间复杂度为O(logN) 删除区间内的元素 左闭右开[start,end) size() clear() 用来清空map，复杂度为O(N)`c++#include&lt;stdio.h&gt;#include using namespace std; int main(){ map&lt;char,int&gt; mp; mp[‘a’]=5; mp[‘b’]=10; mp[‘d’]=40; mp[‘c’]=20; mp[‘c’]=30;//20被覆盖 printf(“%d\\n”,mp[‘c’]);//30 mp.erase(&#39;b&#39;);//删除键为b的映射，也就是b 10 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); } //a 5 //c 30 //d 40 map&lt;char,int&gt;::iterator it=mp.find(&quot;a&quot;); mp.erase(it);//删除a 5 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); } //c 30 //d 40 mp[&#39;e&#39;]=50; mp[&#39;f&#39;]=60; map&lt;char,int&gt;::iterator it=mp.find(&quot;d&quot;); mp.erase(it,mp.end());//删除区间， d 40 e 50 return 0; } ### map排序 1. C++ STL中Map的按Key排序 &lt;p style=&quot;text-indent:2em&quot;&gt;其实，为了实现快速查找，map内部本身就是按序存储的（比如红黑树）。在我们插入&lt; key, value&gt;键值对时，就会按照key的大小顺序进行存储。这也是作为key的类型必须能够进行 &lt; 运算比较的原因。现在我们用string类型作为key，因此，我们的存储就是按学生姓名的字典排序储存的。&lt;/p&gt; ```c++ #include&lt;map&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; typedef pair&lt;string, int&gt; PAIR; ostream&amp; operator&lt;&lt;(ostream&amp; out, const PAIR&amp; p) { return out &lt;&lt; p.first &lt;&lt; &quot;\\t&quot; &lt;&lt; p.second; } int main() { map&lt;string, int&gt; name_score_map; name_score_map[&quot;LiMin&quot;] = 90; name_score_map[&quot;ZiLinMi&quot;] = 79; name_score_map[&quot;BoB&quot;] = 92; name_score_map.insert(make_pair(&quot;Bing&quot;,99)); name_score_map.insert(make_pair(&quot;Albert&quot;,86)); for (map&lt;string, int&gt;::iterator iter = name_score_map.begin();iter != name_score_map.end();++iter) { cout &lt;&lt; *iter &lt;&lt; endl; } return 0; } 现在知道如何为map指定Compare类了，如果我们想自己写一个compare的类，让map按照我们想要的顺序来存储，比如，按照学生姓名的长短排序进行存储，那该怎么做呢？其实很简单，只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。 struct CmpByKeyLength { bool operator()(const string&amp; k1, const string&amp; k2) { return k1.length() &lt; k2.length(); } }; C++ STL中Map的按Value排序虽然不能直接用sort对map进行排序，那么我们可不可以迂回一下，把map中的元素放到序列容器（如vector）中，然后再对这些元素进行排序呢？这个想法看似是可行的。要对序列容器中的元素进行排序，也有个必要条件：就是容器中的元素必须是可比较的，也就是实现了&lt; 操作的。令人兴奋的是，sort算法和map一样，也可以让我们指定元素间如何进行比较，即指定Compare。需要注意的是，map是在定义时指定的，所以传参的时候直接传入函数对象的类名，就像指定key和value时指定的类型名一样；sort算法是在调用时指定的，需要传入一个对象，当然这个也简单，类名()就会调用构造函数生成对象。 int main() { map&lt;string, int&gt; name_score_map; name_score_map[&quot;LiMin&quot;] = 90; name_score_map[&quot;ZiLinMi&quot;] = 79; name_score_map[&quot;BoB&quot;] = 92; name_score_map.insert(make_pair(&quot;Bing&quot;,99)); name_score_map.insert(make_pair(&quot;Albert&quot;,86)); //把map中元素转存到vector中 vector&lt;PAIR&gt; name_score_vec(name_score_map.begin(), name_score_map.end()); sort(name_score_vec.begin(), name_score_vec.end(), CmpByValue()); // sort(name_score_vec.begin(), name_score_vec.end(), cmp_by_value); for (int i = 0; i != name_score_vec.size(); ++i) { cout &lt;&lt; name_score_vec[i] &lt;&lt; endl; } return 0; } STL之hash_maphash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree而，hansh_map却是哈希表来实现的。 map与hash_map总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小！hash_map对空间的要求要比map高很多，所以是以空间换时间的方法，而且，hash_map如果hash函数和hash因子选择不好的话，也许不会达到你要的效果，所以至于用map，还是hash_map，从3个方面来权衡： 查找速度, 数据量, 内存使用，还有一个就是你的经验！没有特别的标准另外可以通过重写 hash_compair仿函数，更改里面关于桶数量的定义，如果取值合适，也可以得到更优的性能。而且如果你的数据是自定义的类型，必须要重写这个仿函数。可以模仿原来的写法，所有的成员函数，成员变量一个不能少！ STL之multimap标准库还定义了一个 multimap 容器，它与 map 类似，所不同的是它允许重复键。这个属性使得 multimap 比预想的要更有用：比如在电话簿中相同的人可以有两个以上电话号码，文件系统中可以将多个符号链接映射到相同的物理文件，或DNS服务器可以将几个URLs映射到相同的IP地址。 multimap的成员函数 begin() :返回指向第一个元素的迭代器 clear() :删除所有元素 count() :返回一个元素出现的次数 empty() :如果multimap为空则返回真 end() :返回一个指向multimap末尾的迭代器 equal_range() :返回指向元素的key为指定值的迭代器对 erase() :删除元素 find() :查找元素 get_allocator() :返回multimap的配置器 insert() :插入元素 key_comp() :返回比较key的函数 lower_bound() :返回键值&gt;=给定元素的第一个位置 max_size() :返回可以容纳的最大元素个数 rbegin() :返回一个指向mulitmap尾部的逆向迭代器 rend() :返回一个指向multimap头部的逆向迭代器 size() :返回multimap中元素的个数 swap() :交换两个multimaps upper_bound() :返回键值&gt;给定元素的第一个位置 value_comp() :返回比较元素value的函数 //multimap允许重复的键值插入容器 // ********************************************************** // * pair只包含一对数值:pair&lt;int,char&gt; * // * map是一个集合类型，永远保持排好序的， * // * map每一个成员就是一个pair,例如：map&lt;int,char&gt; * // * map的insert()可以把一个pair对象作为map的参数,例如map&lt;p&gt; * // *********************************************************** #include&lt;map&gt; #include&lt;iostream&gt; using namespace std; int main(void) { multimap&lt;int,char*&gt; m; //multimap的插入只能用insert()不能用数组 m.insert(pair&lt;int,char*&gt;(1,&quot;apple&quot;)); m.insert(pair&lt;int,char*&gt;(1,&quot;pear&quot;)); //apple和pear的价钱完全有可能是一样的 m.insert(pair&lt;int,char*&gt;(2,&quot;banana&quot;)); //multimap的遍历只能用迭代器方式不能用数组 cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; multimap&lt;int,char*&gt;::iterator i,iend; iend=m.end(); for(i=m.begin();i!=iend;i++) { cout&lt;&lt;(*i).second&lt;&lt;&quot;的价钱是&quot;&lt;&lt;(*i).first&lt;&lt;&quot;元/斤n&quot;; } cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //元素的反相遍历 multimap&lt;int,char*&gt;::reverse_iterator j,jend; jend=m.rend(); for(j=m.rbegin();j!=jend;j++) { cout&lt;&lt;(*j).second&lt;&lt;&quot;的价钱是&quot; &lt;&lt;(*j).first&lt;&lt;&quot;元/斤n&quot;; } cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //元素的搜索find(),pair&lt;iterator,iterator&gt;equal_range(const key_type &amp;k)const //和multiset的用法一样 multimap&lt;int,char*&gt;::iterator s; s=m.find(1);//find()只要找到一个就行了，然后立即返回。 cout&lt;&lt;(*s).second&lt;&lt;&quot; &quot; &lt;&lt;(*s).first&lt;&lt;endl; cout&lt;&lt;&quot;键值等于1的元素个数是：&quot;&lt;&lt;m.count(1)&lt;&lt;endl; cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //删除 erase(),clear() m.erase(1); for(i=m.begin();i!=iend;i++) { cout&lt;&lt;(*i).second&lt;&lt;&quot;的价钱是&quot; &lt;&lt;(*i).first&lt;&lt;&quot;元/斤n&quot;; } return 0; } 遍历// 使用遍历器遍历： Iterator iter = map.entries().iterator(); while(iter.hasNext()) { Map.Entry&lt;Integer, Integer&gt; entry = (Map.Entry&lt;Integer, Integer&gt;)iter.next(); System.out.println(String.format(&quot;%d:%d&quot;, entry.getKey(),entry.getValue())); } //使用Key值遍历，key值可以得到一个全部键值的MultiSet或者是一个没有重复键值的KeySet Set&lt;Integer&gt; keys = map.keySet(); for(int key:keys) { String result = String.format(&quot;%d:&quot;, key); Set&lt;Integer&gt; values = map.get(key); for(int value:values) { result= result+&quot; &quot;+value; } System.out.println(result); } STL之setset，顾名思义，就是数学上的集合——每个元素最多只出现一次，并且set中的元素已经从小到大排好序。 set的成员函数 begin() :返回set容器的第一个元素的地址 end() :返回set容器的最后一个元素地址 clear() :删除set容器中的所有的元素 empty() :判断set容器是否为空 max_size() :返回set容器可能包含的元素最大个数 size() :返回当前set容器中的元素个数 erase(it) :删除迭代器指针it处元素`c++#include #include using namespace std; int main(){ set s; s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;”set 的 size 值为 ：”&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;”set 的 maxsize的值为 ：”&lt;&lt;s.max_size()&lt;&lt;endl; cout&lt;&lt;”set 中的第一个元素是 ：”&lt;&lt;s.begin()&lt;&lt;endl; cout&lt;&lt;”set 中的最后一个元素是:”&lt;&lt;s.end()&lt;&lt;endl; s.clear(); if(s.empty()) { cout&lt;&lt;”set 为空 ！！！”&lt;&lt;endl; } cout&lt;&lt;”set 的 size 值为 ：”&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;”set 的 maxsize的值为 ：”&lt;&lt;s.max_size()&lt;&lt;endl; return 0;} - count() :用来查找set中某个元素出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。 - find(): 用来查找set中某个元素出现的位置。如果找到，就返回这个元素的迭代器，如果这个元素不存在，则返回 s.end() 。 (最后一个元素的下一个位置，s为set的变量名) ```c++ #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;int&gt; s; set&lt;int&gt;::iterator it; //创建一个他对应的迭代器 s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;&quot;set 中 1 出现的次数是 ：&quot;&lt;&lt;s.count(1)&lt;&lt;endl; cout&lt;&lt;&quot;set 中 4 出现的次数是 ：&quot;&lt;&lt;s.count(4)&lt;&lt;endl; it1 = st1.find(4); //查找数据 if (it1 != st1.end()) //如果找到就输出数据 { cout &lt;&lt; *it1 &lt;&lt; endl; } return 0; } 遍历`c++##include #includeusing namespace std; int main(){ set s; //创建一个int类型的set s.insert(10); //插入数据 s.insert(30); s.insert(20); s.insert(40); //遍历数据，用迭代器遍历数据 for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) { cout &lt;&lt; *it &lt;&lt; endl; } //这里用到了set中的元素已经从小到大排好序的性质 return 0; } - set+struct ```c++ #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;string&gt; using namespace std; struct Info { string name; double score; bool operator &lt; (const Info &amp;a) const // 重载“&lt;”操作符，自定义排序规则 { //按score由大到小排序。如果要由小到大排序，使用“&gt;”即可。 return a.score &lt; score; } }; int main() { set&lt;Info&gt; s; Info info; //插入三个元素 info.name = &quot;Jack&quot;; info.score = 80; s.insert(info); info.name = &quot;Tom&quot;; info.score = 99; s.insert(info); info.name = &quot;Steaven&quot;; info.score = 60; s.insert(info); set&lt;Info&gt;::iterator it; for(it = s.begin(); it != s.end(); it++) cout &lt;&lt; (*it).name &lt;&lt; &quot; : &quot; &lt;&lt; (*it).score &lt;&lt; endl; return 0; } /* 运行结果： Tom : 99 Jack : 80 Steaven : 60 */","categories":[{"name":"算法模板","slug":"算法模板","permalink":"/categories/算法模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"算法模板","slug":"算法模板","permalink":"/categories/算法模板/"}]},{"title":"Yisin的数据结构小练习（堆栈+队列）","slug":"Yisin的数据结构小练习（堆栈-队列）","date":"2019-02-02T07:25:11.000Z","updated":"2019-03-16T01:03:34.780Z","comments":true,"path":"2019/02/02/Yisin的数据结构小练习（堆栈-队列）/","link":"","permalink":"/2019/02/02/Yisin的数据结构小练习（堆栈-队列）/","excerpt":"人一我百!人十我万!永不放弃~~~ 怀着自信的心,去追逐梦想 ——kuangbin","text":"人一我百!人十我万!永不放弃~~~ 怀着自信的心,去追逐梦想 ——kuangbin Yisin的数据结构小练习（堆栈+队列）VJ套题题目&lt;–点这里 Password：woyaoac A.OpenJ_Bailian2694.逆波兰表达式逆波兰表达式应该是数据结构入门级别的一道题，然而选的这道题有点小坑，所以写了差不多一个多小时。 后缀的逆波兰式应该是很好写的，但是题目给了前缀表达式。一开始不知道正解应该从右到左逆序读入，就和后缀表达式做法一样了。走了很多弯路：开了符号和数字两个栈，检测到连续push两个数字，则符号顶端出栈，对两个数字进行操作后入栈。当然这个想法错的离谱…… 实现逆序读入我们也可以开一个string类型的栈，全部读入后再依次出栈。是数字则进入double类型的栈，检测到是操作符则从double栈中取出两个元素，计算后再入栈。最后double栈中剩余的元素就是答案了。 AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;stack&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;iomanip&gt; using namespace std; int main() { string s; stack&lt;double&gt;num; stack&lt;string&gt;S; int y=0; while(cin&gt;&gt;s) { S.push(s); char a=getchar(); if(a==&#39;\\n&#39;) break; } while(!S.empty()) { s=S.top(); S.pop(); if(s==&quot;+&quot;||s==&quot;-&quot;||s==&quot;*&quot;||s==&quot;/&quot;) { char c=s[0]; double a,b; a=num.top(); num.pop(); b=num.top(); num.pop(); if(c==&#39;+&#39;) num.push(a+b); else if(c==&#39;-&#39;) num.push(a-b); else if(c==&#39;*&#39;) num.push(b*a); else if(c==&#39;/&#39;) num.push(a/b); } else { num.push(atof(s.c_str())); } } printf(&quot;%f\\n&quot;,num.top()); return 0; } B.ZOJ 3210.A Stack or A Queue?B题着实水啊，基本就是概念检测题，判断stack、queue、both or neither。只要从前往后扫一遍，在从后往前扫一遍，就可以得出答案。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; int a[105],b[105]; for(int i=0;i&lt;m;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;m;i++) cin&gt;&gt;b[i]; int flag1=0,flag2=0; for(int i=0;i&lt;m;i++) { if(a[i]!=b[i]) { flag1=1; break; } } for(int i=0;i&lt;m;i++) { if(a[i]!=b[m-1-i]) { flag2=1; break; } } if(flag1==0&amp;&amp;flag2==0) cout&lt;&lt;&quot;both&quot;&lt;&lt;endl; else if(flag1==0) cout&lt;&lt;&quot;queue&quot;&lt;&lt;endl; else if(flag2==0) cout&lt;&lt;&quot;stack&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;neither&quot;&lt;&lt;endl; } return 0; } C.CodeForces 1104B.Game with string这题是临时换上去的，cf开模拟赛的时候写了这道题感觉比较有价值，就拿过来了。虽然不知道官答是不是用栈写的。（刚才去翻了一下列表，这题应该是典型栈题无疑。） 一个类似于消消乐的操作，相邻元素相同可消，消了以后左右合并，求最大消除总次数。用栈来模拟，遍历字符串，和栈顶元素不同则入栈，相同则取出栈顶元素。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int main() { ios::sync_with_stdio(false); stack&lt;char&gt;game; string s; cin&gt;&gt;s; int ans=0; game.push(s[0]); for(int i=1;i&lt;s.size();i++) { if(game.size()==0) game.push(s[i]); else if(s[i]==game.top()) { game.pop(); ans++; } else { game.push(s[i]); } } if(ans%2==1) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } D.ZOJ 1259.RailsRails是经典的栈题。这是一道入门火车问题。唯一觉得有点烦的是input数据格式怎么这么麻烦。 我们需要两个数组s1，s2和一个stack。s1存放要求的出站顺序，s2存放入站顺序（也就是1-n）。进行数组匹配（不知道能不能这么描述），倘若一样，下一个；不一样，先看看s2和栈顶元素是否相同。相同则栈顶元素出栈，s1元素地址++；不相同则把s2元素入栈，s2元素地址++，直到找到s2中与s1相同的一项，或者s2到达末尾匹配失败。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;cstring&gt; using namespace std; int a[1005],b[1005]; int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); stack&lt;int&gt; s; while(cin&gt;&gt;a[0]) { b[0]=1; int i=0,j=0; if(a[0]==0) { cout&lt;&lt;endl; break; } else { for(int k=1;k&lt;n;k++) { cin&gt;&gt;a[k]; b[k]=k+1; } for(i=0;i&lt;n;i++) { if(a[i]==b[j]) { j++; } else { if(!s.empty()) { if(s.top()==a[i]) { s.pop(); } else { s.push(b[j]); j++; i--; } } else { s.push(b[j]); j++; i--; } } if(j&gt;n) break; } } if(i==n) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } } return 0; } E.ZOJ 2603.Railroad Sort这道火车题在栈的基础上增加了二分分治思想，对递归写的不太好的我来说还是有些困难的。 通过n个站台使2^n辆无序火车有序出站，最简单的安排方式就是通过第一个站台使前2^(n-1)辆火车先出站，通过第二个站台使前2^(n-2)辆火车先出站…… 拿例子8 4 7 1 3 6 5 2举例的话， 1 : 4 1 3 2 | 8 7 6 5 2 : 1 2 | 4 3 | 6 5 | 8 7 3 ： 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 通过一个栈结构，实现每次二分的排序。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int a[10005]; void dfs(int num[],int r,int k) { if(k&lt;=1) return ; int s1[k/2+1]; int s2[k/2+1]; int k1=0,k2=k/2; int l=r-k; int mid=(l+r)/2; stack&lt;int&gt; si; int p1=0,p2=0; for(int i=0;i&lt;k;i++) { if(num[i]&lt;=mid) { s1[p1++]=num[i]; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;&lt;&lt;num[i]&lt;&lt;&quot; &quot;; } else { cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; si.push(num[i]); } } while(!si.empty()) { s2[p2]=si.top(); si.pop(); cout&lt;&lt;s2[p2++]&lt;&lt;&quot; &quot;; } dfs(s1,mid,k/2); dfs(s2,r,k/2); return ; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int m=1&lt;&lt;n; for(int i=0;i&lt;m;i++) cin&gt;&gt;a[i]; dfs(a,m,m); cout&lt;&lt;endl; } return 0; } F.HDU 1023.Train Problem II其实这不算数据结构的题，是排列组合问题下的计数问题，卡特兰数的应用。 详细题解可以移步kuangbin 巨巨的blog。 AC代码： #include&lt;iostream&gt; using namespace std; int a[105][105]; void ktl() { int i,j,yu,len; a[2][0]=a[1][0]=a[1][1]=1; a[2][1]=2; len=1; for(int i=3;i&lt;101;i++) { yu=0; for(int j=1;j&lt;=len;j++) { int t=(a[i-1][j])*(4*i-2)+yu; yu=t/10; a[i][j]=t%10; } while(yu) { a[i][++len]=yu%10; yu/=10; } for(j=len;j&gt;=1;j--) { int t=a[i][j]+yu*10; a[i][j]=t/(i+1); yu=t%(i+1); } while(!a[i][len]) { len--; } a[i][0]=len; } } int main() { ktl(); int n; while(cin&gt;&gt;n) { for(int i=a[n][0];i&gt;0;i--) { cout&lt;&lt;a[n][i]; } cout&lt;&lt;endl; } return 0; } G.ZOJ 1151.Word Reversal题意为给出一句话，对每个单词翻转其中字母的顺序。 网上看到的方法感觉比较繁琐，我给出的思路是读取字符串s，对于每一位判断是否为空格，非空格则入栈，为空格则依次出栈。循环结束后还需要把最后一个单词的字母出栈。 AC代码如下： #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;string&gt; #include&lt;cstdio&gt; using namespace std; int main() { int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; getchar(); while(m--) { string s; getline(cin,s); stack&lt;char&gt; q; for(int i=0;i&lt;s.size();i++) { if(s[i]!=&#39; &#39;) q.push(s[i]); else { while(!q.empty()) { cout&lt;&lt;q.top(); q.pop(); } cout&lt;&lt;&quot; &quot;; } } while(!q.empty()) { cout&lt;&lt;q.top(); q.pop(); } cout&lt;&lt;endl; } if(n&gt;0) cout&lt;&lt;endl; } return 0; } H.HDU 3351.Seinfeld括号配对问题的升级版，问给出一串括号序列，最少需要多少次反转操作，使全部括号配对成功。 利用贪心思想可知，先消去配对成功的括号，再对剩下括号操作。开一个栈，若是 { 则入栈， } 要先判断栈是否为空：若为空，则可知这个括号一定需要反转；不为空，则可配对消除，使一个 { 出栈。遍历一遍以后，栈内余下的左括号需要把其中一半变为右括号，使之配对成功。 AC代码如下： #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;cstdio&gt; #include&lt;string&gt; using namespace std; int main() { string s; getline(cin,s); int m=1; while(s[0]!=&#39;-&#39;) { stack&lt;char&gt;q; int ans=0; for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;{&#39;) { q.push(&#39;{&#39;); } else { if(q.empty()) { ans++; q.push(&#39;{&#39;); } else q.pop(); } } ans+=q.size()/2; cout&lt;&lt;m&lt;&lt;&quot;. &quot;; m++; cout&lt;&lt;ans&lt;&lt;endl; getline(cin,s); } return 0; }","categories":[{"name":"总结","slug":"总结","permalink":"/categories/总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"/tags/总结/"},{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"总结","slug":"总结","permalink":"/categories/总结/"}]},{"title":"岁末有感","slug":"岁末有感","date":"2019-01-28T10:21:05.000Z","updated":"2019-08-05T01:49:17.918Z","comments":true,"path":"2019/01/28/岁末有感/","link":"","permalink":"/2019/01/28/岁末有感/","excerpt":"愿你心中有丘壑，眉目做山河 从此无心爱良夜 任他明月下西楼","text":"愿你心中有丘壑，眉目做山河 从此无心爱良夜 任他明月下西楼 岁末有感如果要总结这一年的话，似乎要从高三后半段开始讲起呢。 高三时候的我么？ 怎么说呢，我在班主任的眼里大概是有点犟又奇奇怪怪的人吧：高三还不好好收收心准备高考，非要停课去搞什么诗词；自习课又不好好待在教室里，非要跑到大教室去待着；模拟考回回都还可以，怎么一到大考就全炸了。我不和她吵，她也从来就没说服过我，我决意的事一向是由着自己性子去做的。 但在其他老师眼中，又有些不同了。语文老师眼里的乖小孩；历史老师眼里的同道中人，“有希望上浙大的学生”（但那个时候选考已经考炸了QAQ）；数学老师眼里上课就没好好听过，基本在睡觉的学生；英语老师眼里有潜力但是又懒得一匹的学生；语文备课组组长眼里每次语文考试作文水平根本就没发挥出来的学生（其实我觉得吧，他说得多了，我就觉得我作文可能真就这个水平）。 一向和老师们相处得都还不错。无论是哪一阶段，总会有关系超级好的老师关照。同学的话，大概是属于那种一半的人不熟，另一半关系还不错，其中又有几个超级亲密。这种东西一向随缘，关系好必然有关系好的理由：和老师关系好可能是因为和他的观点相通，有引为知己的味道（譬如历史老师）；和同学关系好就大概是因着性格相近，接触的机会比较多（譬如高中时候的盈盈和大学时候的钰莹）。 高三的时候其实比高一高二轻松多了，特别是下半学期。只剩语数英三门。对我来说的话，主要就是数学，怎么从不及格（高三开始的时候只能考七八十吧）提到110+就差不多了。但是也没有想象的那么痛苦，开始好好搞数学的时候，提分的速度还是相当快的，基本每次统练都能进步10分，到最后，已经能稳定100分了。其实还是蛮诧异的，因为他们在外面补习的话，懂的知识点的确比我多，但是……我会做的一般不会丢太多分。所以出来的成绩有时候还会比他们高（笑哭）。 高三值得一提的还有去杭电的三一。其实准备三一的过程就是我忙里偷闲，趁机玩一玩的过程。比别人花了更多时间准备，一方面是做事一向未雨绸缪，另一方面，读书太累了啊。 杭电很气派，三一组织的也很好。很感谢这次三一，改变了一个选考爆炸的小可怜的命运。笔试的话因为选考技术加上文科生，所以很占优势。勉勉强强卡线过的。面试是我弱项，但是聊天就不是。所以我尽量放宽心就当和考官在随意扯家常，而且是往我懂的地方扯。结果一个不小心给自己挖坑，回答了很多科技方面的问题（说个笑话，我知道的科技相关的东西全是为平时考试作文服务的）。从杭州回来自我感觉就不错，遂放宽心，知道不管怎么样杭电还是能读的，不会去读台州学院的。（雾） 接下去的高三就很乏味可陈了。按部就班地复习，连历史课都没得上了，没法听徐老师的百家讲坛了啊。高考前夕意外的冷静。之前这种升学考永远是失眠+噩梦，然后就史无前例的垃圾成绩。高考考场答题也比较稳，跟平时感觉差不多，可能还要再好上一点。 高考结束后就马上去杭州了。一是为了冲一冲复旦和交大的三一，二是想散散心。和一个同班同学结伴，住到了她亲戚家。第一天上午考复旦，下午考交大，杭州的交通嘛……那天真的是一直在匆匆忙忙地跑。感受了一下试题的难度，嘛，对没有数竞经验的人来说相当不友好，而且历史和语文知识面真的，广的可怕，大概就五分之一（可能没有）的东西我见过。 当然是毫无疑问就出局了。接下去就可以肆意玩了。我们去了西湖，去了各大商场，去了杭州最大的服装市场，去了博物馆，寄情于山水之间，全然不在意过去的高考了。 成绩出的还是很快的。大概就在回台州过后没几天。看到总分着实有些惊讶，比预计的高，特别是语文。但是这个成绩呢，又是一个尴尬的位置，浙江快到两万的水平。杭电杭电，食之无味，弃之可惜。填三一的话，基本就是提前批录取；不填提前批的话，风险会有一点，但问题也不大。抱着这样的想法，杭电的三一就主动放弃了，虽然面试分数真的蛮高的。 专业的话，其实我还是目标比较明确的：历史，汉语言文学，计算机。哪个都成。历史被我爸毙掉了…….汉语言文学的话，浙师大的分都不够（微笑），更别说一直心心念念的南开和华师大，学这个学校还是很关键的，所以我主动放弃。然后我爸就开始做我工作，想报一些经济类的专业（我半毛钱兴趣都没有），然后就填的不情不愿。 其实觉得我填的第一志愿还蛮有意思的，是一个第一次放在普通批招生的学校。上海海军军医大学，八年临床本硕博连读。本来以为有可能爆冷的，我太小看浙江人的智慧了哈哈哈。 东秦的计算机是第四十五个志愿，现在都还记得很清楚。如果不是东秦的话，大概就是辽大的经济。命运就是这么有趣，总会有它运行的规律。我注定是要学计算机的女人，注定是要离开南方的姑娘。 之前对东秦完全不了解，发现这个“宝藏”学校的是我爸爸，从一堆奇奇怪怪的河北高校里把它挑出来了。抱着随遇而安的想法，老老实实地看了好久东秦的资料，然后去找找有没有高中上届的学长学姐。 遇到ACM Club是一个转折点。之前虽然选考技术，但是VB是真的太简单了，学的算法也就是小儿科。但是对学习c++概念有极大帮助。我比club开课早了一个星期来学c语言，而且club开课后极长一段时间我还是不会c++。哈哈哈所以说我学东西不是很快，其实也不是转不过弯，就是懒得转…… 和紫闻抢榜首的那段时间刺激极了。每晚不到两点真的没法睡觉。然后就被他拉入了邪恶组织（大雾），先刷本校oj，再去写vj的训练。知道有那么多有oi基础的同学，说不慌是不可能的。化压力为动力嘛。暑假后来就没有去玩啦，开始入门ACM（其实都算不上）。 踏上来秦皇岛的火车之前内心惴惴不安，不知道未来会发生什么。火车走得很慢，夜里睡不着，只有一轮明月始终相伴。 成功面基紫闻、谜语学长，然后才见到传说中的50er。大概很多事情都会随着时间推移慢慢改变，只是当时还不知道。所幸终有不变的值得珍惜的东西。就已经很好了。 军训的时候一天比一天黑。但是却是经历的最轻松的一个军训，太好划水了。所以也没有什么独特的记忆，似乎只是平平淡淡的一个星期。对着一群人脸盲，叫不上名字。进入一个新环境的过渡期总是难受极了。 进入ACM Club很顺利，并没有什么曲折。面试的学姐也是暑假认识的浙江小姐姐，水水就放我走了。进入预备队反而是有些险了，第一次差点掉出前十。进入club以后就开始迷茫了，一是因为50er退役带来的冲击太大，还有就是不知道自己的定位，也不知道什么时候离开。爸爸的期望还是很高的，希望能进EC Final，并且夺银。我自己的话就没那么高远的志向。 而且因为经常深夜cf，学习还是受到了很大的影响。譬如我已经心有余而力不足的高数。我又想出国，需要绩点，比赛奖项倒不是什么重要的。 思考的过程是痛苦的。好几个星期郁郁寡欢。最后还是舍不得过早离开热爱的ACM，最早应该也会在大三上退役。组女队的想法也还是一直都在，希望能在这项竞赛里发挥女孩子的长处。 大一学期期末的成绩除了高数，其他应该都还算不错了。camp的参加资格也拿到手。搬到校六的那天心情还是激动不已的。面对未知，我一向怀着憧憬和敬畏。 和婉乔相处得也还算融洽，都是温和的人，都会为对方去着想，日子自然也过得欢快。 坦白说，见识了人外有人，视野开拓了。平时说自闭的话也就是说说，其实心态一直都还好，毕竟cf打多了也就fo了。自闭是不可能自闭的。 我觉得camp最大的收获，是遇见了wls。 能想象么？越深入去读一个人，就越会被感动的感觉。读人大概是一项有趣的事业。报道的那天，wls来的还比较早，坐在我们后面和别人开始侃。一开始我以为是哪所高校的同学，对科技发展竟然这么有见地。后来教主来了，才知道是办camp的老师QAQ。 可巧，上一个这么敬仰的人也是交大的学长。似乎是和交大的不解之缘。 是啊，wls从来就不是一个乖孩子，打架，抑郁症，摔手机，性格暴躁，但是身处这样的环境小绵羊早就被吃掉了。 似乎是因为自己本身性格就比较随心所欲，所以就特别欣赏热血的人，会觉得畏畏缩缩让人不耐。wls办camp的初衷，就是为了发展弱校的ACM事业，给他们指一条路。没有人愿意投资，他就自己赔钱干。似乎是很久没见过这样善良的人了，看见大家为了自己的利益勾心斗角，踢皮球，渐渐地麻木了。wls的出现是一道光，愿将腰下剑，直为斩楼兰。 而且wls本身是个很有意思的人。其实很难想象他曾经有过心理疾病。他看起来，比任何人都能自得其乐。就是一个小小的马玩偶，都能玩得不亦乐乎。他总是对着我们微笑，惯于自黑，想把正能量带给我们。 真的很开心能与wls相遇在这个冬天。天很冷，心却被温暖了。坚持的一切似乎有了答案。 我只是做了我觉得对的事情，仅此而已。 过去未去，而未来已到。与其局限于眼前的琐碎，不如去勇敢畅想未来。视野决定成败。 如果说一年里进入东秦是幸运的，麻雀虽小五脏俱全。东秦给了我很多高校无法给予的机会。那么最幸运的莫过于在东秦，一个冬天，遇见wls。然后知道了什么叫希望。 明年的比赛很多，能否抓住机会，就看寒假能不能沉下心来。不去想，不去懊恼，只管风雨兼程。许个愿吧，参加女生赛，然后出师大捷。人生的起点，刚刚开始呢。加油加油，去做想做的事，去见喜欢的人。","categories":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}],"tags":[{"name":"新年","slug":"新年","permalink":"/tags/新年/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"/categories/随笔/"}]},{"title":"CCPC Wannafly winter camp day1","slug":"CCPC-Wannafly-winter-camp-day1","date":"2019-01-20T15:04:07.000Z","updated":"2019-03-25T14:14:24.755Z","comments":true,"path":"2019/01/20/CCPC-Wannafly-winter-camp-day1/","link":"","permalink":"/2019/01/20/CCPC-Wannafly-winter-camp-day1/","excerpt":"well爆零了 蒟蒻本质暴露无遗 wls说是最简单的一场……然而我感受到满满恶意","text":"well爆零了 蒟蒻本质暴露无遗 wls说是最简单的一场……然而我感受到满满恶意 CCPC Wannafly winter camp day1A.机器人大佬队友出的题，debug过程万分艰辛。 首先要记录是否经过B区的点以及构造的矩形（或线段）的边长范围。特判输出0的情况：只需经过原点。接下来找到包含所需经过的点的最近转折点，需要注意如果s游离在外面，需要把范围扩到s点。分类如果经过B区，则相减加k并乘2；若无，则直接乘2。 的确不太复杂。主要是别遗漏就好。 B.吃豆豆 C.拆拆拆数我们想构造来着……然后，咕了。 用队友的思想，最后问题只需要简化成如何找出利用哥德巴赫猜想把偶数拆成两个素数的规律。事实证明，不存在的。暴力骗过都比天马行空要强…… 隔壁队的暴力思想大概是先把两组拆成相近的，然后先给一组加加减减，如果已经达到二十次还没有实现的话，再让另一组一起动……我一度觉得很神奇，不知道有没有理解错他们的意思。 然后我知道了比较靠谱的方法就是用小素数去凑。行吧，流下了不学无术的泪水。 D.超难的数学题听wls一席话，胜读十年书QAQ 先假定a/b，解方程（a+c)/(b+c)=p。若不可解，则继续寻找下一个a/b。 emmm还是有点懵，不懂a和b如何选定，还是只是随机的。 E.流流流动熟悉的配方，3n+1猜想。i最后一定得1。 然后dp一下。没有写具体的就是证明我不太会，以后一定填坑（自闭 F.爬爬爬山这是我唯一动手写了两个小时的题目，乱交不WA我还WA谁？ 第一反应是借用有代价的最短路的dp。但是没办法想通挖山这块的问题。 听了思路应该是第一座山的高度+k以上高度的山要看看是否挖,但是同学画的那张图我看不懂…… G.双重矩阵若超过n，则可说明x轴，y轴均可被覆盖。 好像就有某种神奇的规律…… H.我爱割葱原来“割葱”是睡觉的意思呀（浙江各地方言千奇百怪 从下往上切葱,找出最小的直接切就完事了 是我理解的太简单了吗？为什么没有看这道题…… I.起起落落反着找转折点 J.奇宝夺兵队友想用贪心，但思路卡在若选宝物最多的人的宝物，从而导致他不是最多的了，则会影响整个结果…… K.星球大战 以上欠的坑等我学成归来再填吧。知识盲点太多了……有点自闭。","categories":[{"name":"总结","slug":"总结","permalink":"/categories/总结/"}],"tags":[{"name":"自闭","slug":"自闭","permalink":"/tags/自闭/"},{"name":"wls","slug":"wls","permalink":"/tags/wls/"},{"name":"camp","slug":"camp","permalink":"/tags/camp/"}],"keywords":[{"name":"总结","slug":"总结","permalink":"/categories/总结/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"图灵杯总结","slug":"图灵杯总结","date":"2018-12-04T09:20:10.000Z","updated":"2019-08-05T01:50:30.542Z","comments":true,"path":"2018/12/04/图灵杯总结/","link":"","permalink":"/2018/12/04/图灵杯总结/","excerpt":"待到秋来九月八，我花开后百花杀 12月2日。阴，有时有雨。 走进科技楼前顺手拍了一张照片 嗯 大雾 蛮符合心境的 有点迷茫，永远找不到前路在何方的感觉","text":"待到秋来九月八，我花开后百花杀 12月2日。阴，有时有雨。 走进科技楼前顺手拍了一张照片 嗯 大雾 蛮符合心境的 有点迷茫，永远找不到前路在何方的感觉 图灵杯总结一天前的广工赛其实打得蛮开心的，出了八题。虽然后来发现暴露出来的问题跟图灵杯差不多 上楼就遇到昕怡学姐了。非常感谢她赛前教的小技巧。虽然这次oj貌似没大崩，至少比赛的时候想到她的小tip，心态就还行 坐到位置上以后，听说可以测试一下运行环境，就顺手把模板打出来了，为下面节省了一点时间（然而这点小时间并没啥卵用 就图个心安 接下去一点时间看了一下板子 特别是平时经常用的高精度相关 一般来说，开始的时候我都是比较有优势的。以前切的水题比较多，拿到题一般就能判断是不是能轻松AC了。所以一开始遥遥领先是意料之中。但是一般到第三四题就会开始掉，一个主要原因是因为准确率开始滑了：本来性格一直就挺粗心的，不是读错题就是没看到细节；然后又太急，最后一发发的罚时算上去反而得不偿失。另一个原因可能是会怕难题：比如说之前见过类似的，不会写；那么比赛的时候不管我能不能写出来，我都会觉得自己死定了，肯定不会啊。大概跟平时写题没有即使补题的不良习惯有关，所以也是花了两天搭这个博客的意义，希望平时能养成做题反思的习惯。 封榜前还剩两题，看了下排名，好像第七。接下去就到了做不出题自闭的阶段了。结束的最后一秒更了一下榜，滑到第九了。后来因为数据的原因有道题重判了，掉成了十二名。拿了个三等奖完事儿了。 本来是冲着二等和最佳来的，结果都没有捧到。那天还是有点小小失落的吧。后来想了想，也没什么。比起以后全国赛里的丢牌，这只是小小的挫折了。也算是个勉励吧。现在还太菜，脚步不能停。 然后对着题榜总结一下自己每道题的思路吧 A题类似于脑筋急转弯，直接读入两个字符串然后依次分类讨论一下就好了，应该是签到题 B题看到最大公约数然后又是从1开始的话，答案一下子就出来了。罚时一发我记得是因为每组数据最后忘记换行了（吐血，这种错误已经犯得得心应手了）。没有先做好像是因为发现G更水，应该是吧。后来看他们过的那么快，在C上WA了一次就来写这题了 C题用个结构体排序很简单的。至于为啥又罚时了……第一次先按战斗值给武士排的序，再按金钱……后来发现应该先排钱少的（我大概是白痴吧） D题我WA了五发（成功从同题数排名前端掉到后端）。原因出在前导零，第一二次审题没看到；第三次忽略了全是零的情况；第四次以为是所有零都要删掉（全是零除外）；第五次莫名其妙又交了一发QAQ……第五次已经不抱希望对了，结果……过的那刻整个人都已经崩溃边缘了，心态被搞得有点瘫痪 E题以为是潘骏出的……刚开始以为是不是找规律，后来想到打表再去搞的时候已经放弃了 F题 我的想法是不断递归然后使用类似二分的思想。但是我的递归一直写的不太好。这次写了半个小时还是有bug，最后也就放弃了。看了标准代码有点简单，难点应该在思维上。想清楚从左往右推进就好了 G题类似于CF的水题吧。CF的水题写的比较多，然后交完A以后一下子就直奔写了这题。太简单了，就不讲了 H题一开始我没信心，后来发现过的人也不少以后就知道是规律题。第一次自己画了一下是 2 4 8 14，但是由于不相信自己，还是先用2的次方试了一下（顺便打了快速幂的板子），WA了一发。然后根据 2 4 8 14推规律，当然没有标准答案归纳的那么好，我觉得是他们的差值是等差数列，然后直接乘完相加。怕数据大了还用了快乘法（其实没必要）。后来听学长说取模都是放着看看的（微笑） 应该说上周的两场比赛也让我更加清楚自己的长短处，还有离梦想有多远。但是我也相信“待到秋来九月八，我花开后百花杀”，有了这份信念，支撑着在这条路走下去的应该不仅仅是一开始懵懵懂懂的追随了。未来会更好的，嗯，我愿意去相信。这周的PAT考试加油叭！","categories":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"比赛总结","slug":"比赛总结","permalink":"/categories/比赛总结/"}]}]}